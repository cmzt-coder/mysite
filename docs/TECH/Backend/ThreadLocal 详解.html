<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ThreadLocal 详解 | Java线程本地存储</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <script>
        // Tailwind配置
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#2563eb',
                        secondary: '#475569',
                        accent: '#3b82f6',
                        light: '#f8fafc',
                        dark: '#1e293b',
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        mono: ['JetBrains Mono', 'Consolas', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .bg-gradient {
                background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            }
            .code-block {
                @apply bg-gray-900 text-gray-100 p-4 rounded-lg overflow-x-auto font-mono text-sm my-4;
            }
            .section-card {
                @apply bg-white dark:bg-dark rounded-xl shadow-md p-6 mb-8 transition-all duration-300 hover:shadow-lg;
            }
            .nav-item {
                @apply px-4 py-2 rounded-md hover:bg-blue-50 dark:hover:bg-gray-800 transition-colors duration-200 cursor-pointer;
            }
            .nav-item.active {
                @apply bg-blue-100 dark:bg-gray-700 font-medium;
            }
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen">
    <!-- 顶部导航 -->
    <header class="sticky top-0 z-50 bg-white/90 dark:bg-gray-900/90 backdrop-blur-sm shadow-sm border-b border-gray-200 dark:border-gray-800">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <i class="fa fa-code text-primary text-xl"></i>
                <h1 class="text-xl font-bold text-primary">ThreadLocal 详解</h1>
            </div>
            <div class="flex items-center space-x-4">
                <button id="theme-toggle" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-800 transition-colors">
                    <i class="fa fa-moon-o dark:hidden text-gray-600"></i>
                    <i class="fa fa-sun-o hidden dark:inline text-yellow-400"></i>
                </button>
                <button id="mobile-menu-btn" class="md:hidden p-2 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-800">
                    <i class="fa fa-bars text-gray-600 dark:text-gray-300"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- 主内容区 -->
    <div class="container mx-auto px-4 py-8 flex flex-col md:flex-row gap-8">
        <!-- 侧边导航 -->
        <aside id="sidebar" class="md:w-1/4 lg:w-1/5 shrink-0 h-[calc(100vh-6rem)] sticky top-20 overflow-y-auto bg-white dark:bg-dark rounded-xl shadow-md p-4 transition-all duration-300 transform md:translate-x-0 -translate-x-full md:static fixed md:relative z-40 left-0 top-20 w-3/4 md:w-auto">
            <nav class="space-y-1">
                <div class="nav-item active" data-target="section-1">
                    <i class="fa fa-info-circle mr-2 text-primary"></i>基本概念与核心特征
                </div>
                <div class="pl-4 space-y-1 border-l-2 border-gray-200 dark:border-gray-700">
                    <div class="nav-item text-sm" data-target="section-1-1">1.1 什么是ThreadLocal</div>
                    <div class="nav-item text-sm" data-target="section-1-2">1.2 线程隔离性的实现原理</div>
                    <div class="nav-item text-sm" data-target="section-1-3">1.3 与其他线程安全机制的对比</div>
                    <div class="nav-item text-sm" data-target="section-1-4">1.4 基本API设计与核心方法</div>
                    <div class="nav-item text-sm" data-target="section-1-5">1.5 典型使用模式</div>
                </div>

                <div class="nav-item" data-target="section-2">
                    <i class="fa fa-cogs mr-2 text-primary"></i>使用方法详解
                </div>
                <div class="pl-4 space-y-1 border-l-2 border-gray-200 dark:border-gray-700">
                    <div class="nav-item text-sm" data-target="section-2-1">2.1 创建和初始化</div>
                    <div class="nav-item text-sm" data-target="section-2-2">2.2 设置和获取变量</div>
                    <div class="nav-item text-sm" data-target="section-2-3">2.3 使用remove()清理资源</div>
                    <div class="nav-item text-sm" data-target="section-2-4">2.4 线程间数据传递</div>
                    <div class="nav-item text-sm" data-target="section-2-5">2.5 线程池环境处理</div>
                </div>

                <div class="nav-item" data-target="section-3">
                    <i class="fa fa-puzzle-piece mr-2 text-primary"></i>运行原理深度剖析
                </div>
                <div class="pl-4 space-y-1 border-l-2 border-gray-200 dark:border-gray-700">
                    <div class="nav-item text-sm" data-target="section-3-1">3.1 核心存储结构</div>
                    <div class="nav-item text-sm" data-target="section-3-2">3.2 数据读写流程</div>
                    <div class="nav-item text-sm" data-target="section-3-3">3.3 弱引用机制</div>
                    <div class="nav-item text-sm" data-target="section-3-4">3.4 哈希冲突处理</div>
                    <div class="nav-item text-sm" data-target="section-3-5">3.5 内存泄漏机制与预防</div>
                </div>

                <div class="nav-item" data-target="section-4">
                    <i class="fa fa-th-large mr-2 text-primary"></i>典型应用场景
                </div>
                <div class="pl-4 space-y-1 border-l-2 border-gray-200 dark:border-gray-700">
                    <div class="nav-item text-sm" data-target="section-4-1">4.1 数据库连接和事务管理</div>
                    <div class="nav-item text-sm" data-target="section-4-2">4.2 用户会话和上下文管理</div>
                    <div class="nav-item text-sm" data-target="section-4-3">4.3 日志追踪和链路监控</div>
                    <div class="nav-item text-sm" data-target="section-4-4">4.4 线程安全的工具类管理</div>
                    <div class="nav-item text-sm" data-target="section-4-5">4.5 避免方法参数传递</div>
                </div>
            </nav>
        </aside>

        <!-- 主内容 -->
        <main class="md:w-3/4 lg:w-4/5">
            <!-- 一、ThreadLocal基本概念与核心特征 -->
            <section id="section-1" class="section-card">
                <h2 class="text-2xl font-bold text-primary mb-6 flex items-center">
                    <i class="fa fa-info-circle mr-3"></i>一、ThreadLocal基本概念与核心特征
                </h2>

                <div id="section-1-1" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">1.1 什么是ThreadLocal</h3>
                    <p class="mb-4 leading-relaxed">
                        <strong class="text-primary">ThreadLocal是Java中用于实现线程本地存储的工具类</strong>，其核心功能是为每个线程创建独立的变量副本，避免多线程环境下的变量共享问题，从而简化线程安全编程。从官方文档的定义来看，ThreadLocal提供线程局部变量，这些变量与普通变量的区别在于，<strong>每个访问该变量的线程（通过get或set方法）都有自己独立初始化的变量副本</strong>。
                    </p>
                    <p class="mb-4 leading-relaxed">
                        ThreadLocal的核心思想可以用一个形象的比喻来理解：它就像每个线程的"私人储物柜"，每个线程都有自己的独立空间，存进去的东西只有自己能拿到，其他线程看不见也摸不着。这种设计确保了线程间的数据隔离，使得每个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本。
                    </p>
                    <p class="leading-relaxed">
                        从技术实现角度看，<strong>ThreadLocal是通过每个线程单独一份存储空间来实现线程隔离的</strong>，每个ThreadLocal只能保存一个变量副本。这种设计与传统的共享变量加锁机制形成了鲜明对比，它采用"空间换时间"的策略，通过为每个线程创建独立副本，从根本上避免了线程间的竞争和同步开销。
                    </p>
                </div>

                <div id="section-1-2" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">1.2 线程隔离性的实现原理</h3>
                    <p class="mb-4 leading-relaxed">
                        ThreadLocal的线程隔离性基于其独特的存储架构。<strong>每个Thread对象内部都维护一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals</strong>，这个map就是线程本地变量的存储容器。当线程通过ThreadLocal的get()或set()方法访问变量时，实际上操作的是该线程独有的数据，而不是全局共享的数据。
                    </p>
                    
                    <div class="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg mb-4 border-l-4 border-primary">
                        <h4 class="font-medium mb-2">这种隔离机制的实现具有以下特点：</h4>
                        <ul class="list-disc pl-5 space-y-2">
                            <li><strong>线程隔离性</strong>：每个线程对ThreadLocal变量的修改对其他线程是不可见的。每个线程通过ThreadLocalMap存储自己的变量副本，实现线程隔离，线程对ThreadLocal变量的读写操作都局限在自己的ThreadLocalMap中，与其他线程完全隔离。</li>
                            <li><strong>无锁设计</strong>：通过复制变量避免同步，性能优于锁机制。由于变量不共享，无需使用synchronized等同步机制，从根本上消除了线程间的竞争条件。</li>
                            <li><strong>内存效率</strong>：相比创建多个对象实例，ThreadLocal通常更节省内存。它通过复用ThreadLocal实例，仅为每个线程创建必要的副本，避免了对象的重复创建。</li>
                        </ul>
                    </div>
                </div>

                <div id="section-1-3" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">1.3 与其他线程安全机制的对比</h3>
                    <p class="mb-4 leading-relaxed">
                        ThreadLocal与传统的线程安全机制（如synchronized）在设计理念和应用场景上存在本质差异，理解这些差异对于正确使用ThreadLocal至关重要。
                    </p>
                    
                    <div class="overflow-x-auto mb-6">
                        <table class="min-w-full bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg">
                            <thead>
                                <tr class="bg-gray-100 dark:bg-gray-700">
                                    <th class="py-3 px-4 text-left border-b dark:border-gray-600">特性</th>
                                    <th class="py-3 px-4 text-left border-b dark:border-gray-600">ThreadLocal</th>
                                    <th class="py-3 px-4 text-left border-b dark:border-gray-600">Synchronized</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                                    <td class="py-3 px-4 border-b dark:border-gray-600 font-medium">解决问题</td>
                                    <td class="py-3 px-4 border-b dark:border-gray-600">线程间数据隔离（空间换时间）</td>
                                    <td class="py-3 px-4 border-b dark:border-gray-600">多线程访问共享资源的互斥（时间换空间）</td>
                                </tr>
                                <tr class="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                                    <td class="py-3 px-4 border-b dark:border-gray-600 font-medium">线程安全</td>
                                    <td class="py-3 px-4 border-b dark:border-gray-600">每个线程独立副本，天然安全</td>
                                    <td class="py-3 px-4 border-b dark:border-gray-600">通过锁机制保证原子性</td>
                                </tr>
                                <tr class="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                                    <td class="py-3 px-4 border-b dark:border-gray-600 font-medium">适用场景</td>
                                    <td class="py-3 px-4 border-b dark:border-gray-600">数据需线程隔离（如会话信息）</td>
                                    <td class="py-3 px-4 border-b dark:border-gray-600">共享资源的同步访问（如计数器）</td>
                                </tr>
                                <tr class="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                                    <td class="py-3 px-4 border-b dark:border-gray-600 font-medium">性能</td>
                                    <td class="py-3 px-4 border-b dark:border-gray-600">无锁，性能高</td>
                                    <td class="py-3 px-4 border-b dark:border-gray-600">锁竞争可能导致性能下降</td>
                                </tr>
                                <tr class="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                                    <td class="py-3 px-4 border-b dark:border-gray-600 font-medium">复杂性</td>
                                    <td class="py-3 px-4 border-b dark:border-gray-600">简单，需关注内存管理</td>
                                    <td class="py-3 px-4 border-b dark:border-gray-600">需设计锁策略，防止死锁</td>
                                </tr>
                                <tr class="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                                    <td class="py-3 px-4 font-medium">内存开销</td>
                                    <td class="py-3 px-4">每个线程一份副本</td>
                                    <td class="py-3 px-4">共享一份数据</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="mb-4">
                        <canvas id="comparisonChart" width="400" height="200"></canvas>
                    </div>

                    <p class="leading-relaxed">
                        从表格可以看出，<strong>ThreadLocal适合线程独占数据的场景</strong>，如数据库连接、用户会话等，而synchronized适合共享资源访问的场景，如计数器、共享缓存。ThreadLocal通过为每个线程提供独立副本，彻底避免了资源竞争，而synchronized则是在共享资源的基础上通过互斥机制保证线程安全。
                    </p>
                </div>

                <div id="section-1-4" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">1.4 基本API设计与核心方法</h3>
                    <p class="mb-4 leading-relaxed">
                        ThreadLocal提供了简洁而强大的API，主要包括以下核心方法：
                    </p>
                    
                    <div class="space-y-4">
                        <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
                            <h4 class="font-medium text-primary mb-2">构造方法：</h4>
                            <ul class="list-disc pl-5 space-y-1">
                                <li><code class="bg-gray-200 dark:bg-gray-700 px-1 py-0.5 rounded text-sm">public ThreadLocal()</code>：创建一个线程本地变量</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
                            <h4 class="font-medium text-primary mb-2">核心方法：</h4>
                            <ul class="list-disc pl-5 space-y-2">
                                <li><code class="bg-gray-200 dark:bg-gray-700 px-1 py-0.5 rounded text-sm">public T get()</code>：返回当前线程的此线程局部变量副本中的值。如果该变量没有当前线程的值，将首先调用initialValue()方法进行初始化</li>
                                <li><code class="bg-gray-200 dark:bg-gray-700 px-1 py-0.5 rounded text-sm">protected T initialValue()</code>：返回当前线程的"初始值"。该方法在第一次调用get()时被调用，除非线程之前调用过set()方法。默认实现返回null</li>
                                <li><code class="bg-gray-200 dark:bg-gray-700 px-1 py-0.5 rounded text-sm">public void set(T value)</code>：将当前线程的此线程局部变量副本设置为指定值</li>
                                <li><code class="bg-gray-200 dark:bg-gray-700 px-1 py-0.5 rounded text-sm">public void remove()</code>：移除当前线程的此线程局部变量值。后续调用get()时，会重新调用initialValue()方法初始化，除非再次调用set()</li>
                                <li><code class="bg-gray-200 dark:bg-gray-700 px-1 py-0.5 rounded text-sm">public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier)</code>：创建一个带有初始值的线程局部变量，初始值由Supplier的get()方法确定。这是Java 8引入的新方法</li>
                            </ul>
                        </div>
                    </div>
                    
                    <p class="mt-4 leading-relaxed">
                        这些方法的设计体现了ThreadLocal的设计哲学：<strong>简单易用、功能专注</strong>。通过这几个核心方法，开发者可以轻松实现线程级别的数据隔离和管理。
                    </p>
                </div>

                <div id="section-1-5">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">1.5 ThreadLocal的典型使用模式</h3>
                    <p class="mb-4 leading-relaxed">
                        基于上述基本概念，ThreadLocal的典型使用模式包括以下几种：
                    </p>
                    
                    <div class="grid md:grid-cols-3 gap-4 mb-4">
                        <div class="bg-white dark:bg-gray-800 p-4 rounded-lg border border-blue-100 dark:border-blue-900 shadow-sm hover:shadow-md transition-shadow">
                            <div class="flex items-center mb-2">
                                <div class="w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center mr-2">
                                    <i class="fa fa-clone text-primary"></i>
                                </div>
                                <h4 class="font-medium">独立副本模式</h4>
                            </div>
                            <p class="text-sm leading-relaxed">
                                为每个线程创建独立的对象副本，如数据库连接、SimpleDateFormat等线程不安全的对象。通过ThreadLocal为每个线程提供专属实例，避免线程安全问题。
                            </p>
                        </div>
                        
                        <div class="bg-white dark:bg-gray-800 p-4 rounded-lg border border-blue-100 dark:border-blue-900 shadow-sm hover:shadow-md transition-shadow">
                            <div class="flex items-center mb-2">
                                <div class="w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center mr-2">
                                    <i class="fa fa-exchange text-primary"></i>
                                </div>
                                <h4 class="font-medium">上下文传递模式</h4>
                            </div>
                            <p class="text-sm leading-relaxed">
                                在复杂的调用链中传递上下文信息，如用户认证信息、请求ID等。通过ThreadLocal可以避免在方法参数中层层传递这些信息，提高代码的简洁性和可维护性。
                            </p>
                        </div>
                        
                        <div class="bg-white dark:bg-gray-800 p-4 rounded-lg border border-blue-100 dark:border-blue-900 shadow-sm hover:shadow-md transition-shadow">
                            <div class="flex items-center mb-2">
                                <div class="w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center mr-2">
                                    <i class="fa fa-tasks text-primary"></i>
                                </div>
                                <h4 class="font-medium">状态管理模式</h4>
                            </div>
                            <p class="text-sm leading-relaxed">
                                在多线程环境下管理线程的执行状态，如事务上下文、任务进度等。每个线程可以独立维护自己的状态，互不干扰。
                            </p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 二、ThreadLocal的使用方法详解 -->
            <section id="section-2" class="section-card">
                <h2 class="text-2xl font-bold text-primary mb-6 flex items-center">
                    <i class="fa fa-cogs mr-3"></i>二、ThreadLocal的使用方法详解
                </h2>

                <div id="section-2-1" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">2.1 创建和初始化ThreadLocal实例</h3>
                    <p class="mb-4 leading-relaxed">
                        创建ThreadLocal实例是使用的第一步，根据不同的需求，有多种创建和初始化方式可供选择。
                    </p>
                    
                    <div class="mb-4">
                        <h4 class="font-medium mb-2">基本创建方式：</h4>
                        <pre class="code-block">
private static final ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();</pre>
                        <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                            这是最基本的创建方式，创建了一个初始值为null的ThreadLocal实例。在实际使用中，建议使用<strong>static final修饰符</strong>来声明ThreadLocal实例，这样做有两个好处：一是避免重复创建实例，节省内存；二是便于统一管理生命周期。
                        </p>
                    </div>
                    
                    <div class="mb-4">
                        <h4 class="font-medium mb-2">提供初始值的方式：</h4>
                        
                        <p class="mb-2">1. <strong>重写initialValue()方法</strong>：</p>
                        <pre class="code-block">
private static final ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;() {
    @Override
    protected String initialValue() {
        return "默认值"; // 线程首次调用get()时返回此值
    }
};</pre>
                        
                        <p class="mt-4 mb-2">2. <strong>使用withInitial()方法（Java 8+）</strong>：</p>
                        <pre class="code-block">
private static final ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -> "默认值");</pre>
                        
                        <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                            这两种方式都可以为ThreadLocal提供初始值，避免返回null导致的NPE（NullPointerException）。withInitial()方法是Java 8引入的新特性，它使用函数式接口Supplier来提供初始值，代码更加简洁优雅。
                        </p>
                    </div>
                    
                    <div>
                        <h4 class="font-medium mb-2">泛型类型的使用：</h4>
                        <p class="mb-2">
                            ThreadLocal支持泛型，使用时应尽量指定具体的类型，避免使用Object类型，这样可以减少类型转换的错误，也让代码更加清晰。例如：
                        </p>
                        <pre class="code-block">
// 正确做法：指定具体类型
ThreadLocal&lt;String&gt; strThreadLocal = new ThreadLocal&lt;&gt;();

// 错误做法：使用Object类型
ThreadLocal&lt;Object&gt; objThreadLocal = new ThreadLocal&lt;&gt;();</pre>
                    </div>
                </div>

                <div id="section-2-2" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">2.2 设置和获取线程局部变量</h3>
                    <p class="mb-4 leading-relaxed">
                        设置和获取线程局部变量是ThreadLocal的核心操作，这两个操作都具有线程隔离性。
                    </p>
                    
                    <div class="grid md:grid-cols-2 gap-6 mb-6">
                        <div>
                            <h4 class="font-medium mb-2">设置值（set方法）：</h4>
                            <pre class="code-block">
// 在当前线程中存储数据
threadLocal.set("线程本地数据");</pre>
                            <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                                set方法将当前线程的ThreadLocal变量设置为指定值。<strong>需要注意的是，这个值只对当前线程可见</strong>，其他线程无法访问或修改这个值。
                            </p>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">获取值（get方法）：</h4>
                            <pre class="code-block">
// 在当前线程中获取数据
String data = threadLocal.get();</pre>
                            <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                                get方法返回当前线程的ThreadLocal变量值。如果这是线程第一次调用get()方法，且之前没有调用过set()方法，则会调用initialValue()方法初始化并返回初始值。
                            </p>
                        </div>
                    </div>
                    
                    <div>
                        <h4 class="font-medium mb-2">线程安全的使用示例：</h4>
                        <pre class="code-block">
public class ThreadLocalExample {
    private static final ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();

    public static void main(String[] args) {
        Runnable task = () -> {
            // 设置当前线程的ID作为值
            threadLocal.set(Thread.currentThread().getId());
            System.out.println(Thread.currentThread().getName() + ": " + threadLocal.get());
            threadLocal.remove(); // 清理
        };

        Thread t1 = new Thread(task, "Thread-1");
        Thread t2 = new Thread(task, "Thread-2");
        t1.start();
        t2.start();
    }
}</pre>
                        <p class="mt-2 mb-2">输出结果：</p>
                        <pre class="code-block">
Thread-1: 10
Thread-2: 11</pre>
                        <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                            这个示例展示了每个线程如何独立地设置和获取自己的ThreadLocal值，体现了线程隔离的特性。
                        </p>
                    </div>
                </div>

                <div id="section-2-3" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">2.3 使用remove()方法清理资源</h3>
                    <div class="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg border-l-4 border-yellow-500 mb-4">
                        <p class="font-medium text-yellow-800 dark:text-yellow-300">
                            <i class="fa fa-exclamation-triangle mr-2"></i><strong>重要提示：</strong>remove()方法是防止内存泄漏的关键，必须正确使用。
                        </p>
                    </div>
                    
                    <p class="mb-4 leading-relaxed">
                        remove()方法用于移除当前线程的ThreadLocal变量值，后续调用get()时会重新调用initialValue()方法初始化，除非再次调用set()方法。
                    </p>
                    
                    <div class="space-y-4 mb-4">
                        <div>
                            <h4 class="font-medium mb-2">1. 使用try-finally块确保清理：</h4>
                            <pre class="code-block">
try {
    threadLocal.set(value);
    // 业务逻辑...
} finally {
    threadLocal.remove(); // 就像用完厕所要冲水！
}</pre>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">2. 线程池环境下的清理：</h4>
                            <pre class="code-block">
ExecutorService executor = Executors.newFixedThreadPool(2);
executor.submit(() -> {
    try {
        threadLocal.set(value);
        // 任务逻辑
    } finally {
        threadLocal.remove(); // 必须清理！
    }
});</pre>
                        </div>
                    </div>
                    
                    <div class="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg">
                        <h4 class="font-medium mb-2">为什么必须调用remove()？</h4>
                        <p class="mb-2">原因有两个：</p>
                        <ul class="list-disc pl-5 space-y-1">
                            <li>一是线程池中的线程会被重用，不remove会导致上次的数据残留（内存泄漏+脏数据）；</li>
                            <li>二是避免ThreadLocalMap中积累无效的Entry，导致内存泄漏。</li>
                        </ul>
                    </div>
                </div>

                <div id="section-2-4" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">2.4 处理线程间数据传递问题</h3>
                    <p class="mb-4 leading-relaxed">
                        ThreadLocal的一个重要特性是<strong>数据仅在当前线程可见</strong>，即使子线程也无法访问父线程的本地变量。这是ThreadLocal设计的基本原则，但在某些场景下可能需要父子线程间的数据传递。
                    </p>
                    
                    <div class="mb-6">
                        <h4 class="font-medium mb-2">默认情况下父子线程无法共享数据：</h4>
                        <pre class="code-block">
ThreadLocal&lt;String&gt; parentData = new ThreadLocal&lt;&gt;();
parentData.set("父线程数据");

new Thread(() -> {
    // 这里获取不到parentData的值！
    System.out.println("子线程获取到的数据：" + parentData.get());
}).start();</pre>
                        <p class="mt-2 mb-2">输出结果：</p>
                        <pre class="code-block">
子线程获取到的数据：null</pre>
                    </div>
                    
                    <div>
                        <h4 class="font-medium mb-2">解决方案：使用InheritableThreadLocal</h4>
                        <p class="mb-2">
                            如果需要父子线程间传递数据，可以使用InheritableThreadLocal，它是ThreadLocal的子类，允许子线程继承父线程的ThreadLocal值。
                        </p>
                        <pre class="code-block">
InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = new InheritableThreadLocal&lt;&gt;();
inheritableThreadLocal.set("父线程数据");

new Thread(() -> {
    // 子线程可以获取到父线程的数据
    System.out.println("子线程获取到的数据：" + inheritableThreadLocal.get());
}).start();</pre>
                        <p class="mt-2 mb-2">输出结果：</p>
                        <pre class="code-block">
子线程获取到的数据：父线程数据</pre>
                        
                        <div class="mt-4 bg-orange-50 dark:bg-orange-900/20 p-3 rounded-lg text-sm">
                            <p class="font-medium text-orange-800 dark:text-orange-300">注意事项：</p>
                            <p class="mt-1">
                                InheritableThreadLocal也有一些限制和风险：一是可能导致内存泄漏，因为子线程可能持有父线程的数据引用；二是如果修改了共享对象的属性，会影响到父线程的数据。因此，使用时需要谨慎。
                            </p>
                        </div>
                    </div>
                </div>

                <div id="section-2-5">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">2.5 线程池环境下的特殊处理</h3>
                    <p class="mb-4 leading-relaxed">
                        线程池环境下使用ThreadLocal需要特别小心，因为线程池中的线程会被重用，可能导致数据污染和内存泄漏。
                    </p>
                    
                    <div class="mb-6">
                        <h4 class="font-medium mb-2">线程池中的数据残留问题：</h4>
                        <pre class="code-block">
public class ThreadPoolIssue {
    private static final ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();

    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(1);

        executor.submit(() -> {
            threadLocal.set("Task1");
            System.out.println("任务1：" + threadLocal.get()); // 输出 Task1
        });

        executor.submit(() -> {
            System.out.println("任务2：" + threadLocal.get()); // 输出 Task1（数据污染）
        });

        executor.shutdown();
    }
}</pre>
                        <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                            这个示例展示了线程池环境下的典型问题：第二个任务获取到了第一个任务设置的数据，这就是数据污染。
                        </p>
                    </div>
                    
                    <div class="mb-4">
                        <h4 class="font-medium mb-2">正确的处理方式：</h4>
                        <pre class="code-block">
executor.submit(() -> {
    try {
        threadLocal.set("Task2");
        System.out.println("任务2：" + threadLocal.get());
    } finally {
        threadLocal.remove(); // 必须清理
    }
});</pre>
                    </div>
                    
                    <div class="bg-green-50 dark:bg-green-900/20 p-4 rounded-lg">
                        <h4 class="font-medium mb-2">最佳实践：</h4>
                        <ol class="list-decimal pl-5 space-y-1">
                            <li><strong>始终在finally块中调用remove()方法</strong></li>
                            <li>在线程池环境下格外小心</li>
                            <li>每次任务开始执行前最好都通过set()方法设置正确的ThreadLocal变量值，确保不会因为线程复用而出现数据混乱</li>
                        </ol>
                    </div>
                </div>
            </section>

            <!-- 三、ThreadLocal的运行原理深度剖析 -->
            <section id="section-3" class="section-card">
                <h2 class="text-2xl font-bold text-primary mb-6 flex items-center">
                    <i class="fa fa-puzzle-piece mr-3"></i>三、ThreadLocal的运行原理深度剖析
                </h2>

                <div id="section-3-1" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">3.1 核心存储结构：Thread、ThreadLocal和ThreadLocalMap</h3>
                    <p class="mb-4 leading-relaxed">
                        要深入理解ThreadLocal的运行原理，首先需要了解其核心存储结构。ThreadLocal的实现基于三个关键组件的协作：<strong>Thread</strong>、<strong>ThreadLocal</strong>和<strong>ThreadLocalMap</strong>。
                    </p>
                    
                    <div class="space-y-6 mb-4">
                        <div>
                            <h4 class="font-medium mb-2">Thread类中的关键变量：</h4>
                            <p class="mb-2">
                                每个Thread对象内部都维护一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个变量就是线程本地变量的存储容器。在Thread类的源码中可以看到：
                            </p>
                            <pre class="code-block">
public class Thread implements Runnable {
    ThreadLocal.ThreadLocalMap threadLocals = null;
    // 其他代码...
}</pre>
                            <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                                这个设计的核心思想是：<strong>每个线程拥有自己的ThreadLocalMap，用于存储该线程的所有ThreadLocal变量</strong>。这种设计确保了线程间的数据隔离，每个线程只能访问自己的ThreadLocalMap，无法访问其他线程的。
                            </p>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">ThreadLocalMap的结构：</h4>
                            <p class="mb-2">
                                ThreadLocalMap是ThreadLocal的静态内部类，它本质上是一个定制化的哈希表。其核心结构如下：
                            </p>
                            <pre class="code-block">
static class ThreadLocalMap {
    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
        Object value;
        Entry(ThreadLocal&lt;?&gt; k, Object v) {
            super(k);
            value = v;
        }
    }
    
    private Entry[] table;
    // 其他代码...
}</pre>
                            <p class="mt-2 mb-2">这里有两个关键要点：</p>
                            <ul class="list-disc pl-5 space-y-1">
                                <li><strong>Entry继承自WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</strong>，这意味着Entry的key（ThreadLocal实例）是弱引用</li>
                                <li><strong>每个Entry存储一个键值对</strong>，key是ThreadLocal实例，value是线程本地变量的值</li>
                            </ul>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">存储关系的完整视图：</h4>
                            <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700 font-mono text-sm">
<pre>线程Thread
  ↳ threadLocals（ThreadLocalMap类型）
      ↳ table（Entry数组）
          ↳ Entry（key=ThreadLocal实例（弱引用），value=线程本地变量）</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="section-3-2" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">3.2 数据读写的核心流程</h3>
                    <p class="mb-4 leading-relaxed">
                        理解ThreadLocal的工作原理，关键在于理解数据读写的具体流程。
                    </p>
                    
                    <div class="space-y-6 mb-4">
                        <div>
                            <h4 class="font-medium mb-2">set(T value)方法的执行流程：</h4>
                            <pre class="code-block">
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        map.set(this, value); // 使用当前ThreadLocal实例作为Key
    } else {
        createMap(t, value);
    }
}</pre>
                            <div class="mt-4 bg-gray-50 dark:bg-gray-800 p-3 rounded-lg">
                                <h5 class="font-medium mb-2">流程分析：</h5>
                                <ol class="list-decimal pl-5 space-y-1">
                                    <li>获取当前线程t</li>
                                    <li>获取线程t的ThreadLocalMap（threadLocals）</li>
                                    <li>如果map不为null，调用map.set(this, value)，这里使用当前ThreadLocal实例作为key</li>
                                    <li>如果map为null，创建新的ThreadLocalMap并设置初始值</li>
                                </ol>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">get()方法的执行流程：</h4>
                            <pre class="code-block">
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}</pre>
                            <div class="mt-4 bg-gray-50 dark:bg-gray-800 p-3 rounded-lg">
                                <h5 class="font-medium mb-2">流程分析：</h5>
                                <ol class="list-decimal pl-5 space-y-1">
                                    <li>获取当前线程t</li>
                                    <li>获取线程t的ThreadLocalMap</li>
                                    <li>如果map不为null，调用map.getEntry(this)查找对应的Entry</li>
                                    <li>如果找到Entry，返回其value</li>
                                    <li>如果map为null或未找到Entry，调用setInitialValue()初始化并返回初始值</li>
                                </ol>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">createMap方法：</h4>
                            <pre class="code-block">
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}</pre>
                            <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                                createMap方法会创建一个新的ThreadLocalMap，并将当前ThreadLocal实例和初始值作为第一个Entry存入。
                            </p>
                        </div>
                    </div>
                </div>

                <div id="section-3-3" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">3.3 弱引用机制的设计原理</h3>
                    <p class="mb-4 leading-relaxed">
                        ThreadLocalMap中使用弱引用是一个关键的设计决策，理解这个设计对于正确使用ThreadLocal至关重要。
                    </p>
                    
                    <div class="space-y-6 mb-4">
                        <div>
                            <h4 class="font-medium mb-2">为什么使用弱引用？</h4>
                            <div class="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg mb-3">
                                <p class="mb-2">ThreadLocalMap的Entry使用弱引用指向ThreadLocal实例，这是为了防止内存泄漏。假设Entry使用强引用：</p>
                                <ul class="list-disc pl-5 space-y-1">
                                    <li>如果外部强引用（如userContext变量）被置为null</li>
                                    <li>但ThreadLocalMap的key仍强引用ThreadLocal对象</li>
                                    <li>导致ThreadLocal对象永远无法被回收，造成内存泄漏</li>
                                </ul>
                            </div>
                            <p class="text-sm text-gray-600 dark:text-gray-400">
                                使用弱引用的设计是"最后一道防线"：当外部强引用消失后，下次GC会回收ThreadLocal对象。这样可以避免ThreadLocal对象本身的泄漏。
                            </p>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">弱引用带来的问题</h4>
                            <div class="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg">
                                <p class="mb-2">然而，弱引用机制并不能完全解决内存泄漏问题，它只是解决了ThreadLocal对象本身的泄漏。如果线程长期存活（如线程池中的线程），且没有调用remove()方法，仍然会导致内存泄漏，因为：</p>
                                <ol class="list-decimal pl-5 space-y-1">
                                    <li>ThreadLocal对象被GC回收，Entry的key变为null</li>
                                    <li>但Entry的value仍被线程的ThreadLocalMap强引用</li>
                                    <li>如果线程不结束，value永远无法被回收</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="section-3-4" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">3.4 哈希冲突的处理机制</h3>
                    <p class="mb-4 leading-relaxed">
                        ThreadLocalMap使用开放地址法（线性探测）来解决哈希冲突，这种设计与HashMap的链表法不同，具有独特的特点。
                    </p>
                    
                    <div class="space-y-6 mb-4">
                        <div>
                            <h4 class="font-medium mb-2">set操作中的哈希冲突处理：</h4>
                            <pre class="code-block">
private void set(ThreadLocal&lt;?&gt; key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);
    
    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&lt;?&gt; k = e.get();
        
        if (k == key) {
            e.value = value;
            return;
        }
        
        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }
    
    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        rehash();
}</pre>
                            <div class="mt-4 bg-gray-50 dark:bg-gray-800 p-3 rounded-lg">
                                <h5 class="font-medium mb-2">处理流程：</h5>
                                <ol class="list-decimal pl-5 space-y-1">
                                    <li>计算初始哈希索引i = key.threadLocalHashCode & (len-1)</li>
                                    <li>如果tab[i]不为null，说明发生冲突，使用线性探测寻找下一个空位</li>
                                    <li>循环检查每个位置：
                                        <ul class="list-disc pl-5 mt-1 space-y-1">
                                            <li>如果找到key相同的Entry，更新value</li>
                                            <li>如果找到key为null的Entry（即过期Entry），调用replaceStaleEntry方法处理</li>
                                        </ul>
                                    </li>
                                    <li>如果找到空位，创建新的Entry</li>
                                </ol>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">get操作中的哈希冲突处理：</h4>
                            <pre class="code-block">
private Entry getEntry(ThreadLocal&lt;?&gt; key) {
    int i = key.threadLocalHashCode & (table.length - 1);
    Entry e = table[i];
    if (e != null && e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}</pre>
                            <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                                如果初始位置的Entry不是目标Entry，会调用getEntryAfterMiss方法进行线性探测，直到找到目标Entry或遇到null。
                            </p>
                        </div>
                    </div>
                </div>

                <div id="section-3-5">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">3.5 内存泄漏的产生机制与预防</h3>
                    <p class="mb-4 leading-relaxed">
                        内存泄漏是使用ThreadLocal时最需要关注的问题，理解其产生机制对于正确使用至关重要。
                    </p>
                    
                    <div class="space-y-6 mb-4">
                        <div>
                            <h4 class="font-medium mb-2">内存泄漏的产生路径：</h4>
                            <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700 mb-3">
                                <ol class="list-decimal pl-5 space-y-2">
                                    <li><strong>外部强引用消失</strong>：当保存ThreadLocal引用的变量（如userContext）被置为null</li>
                                    <li><strong>ThreadLocal对象被GC回收</strong>：由于Entry使用弱引用，ThreadLocal对象会被垃圾回收</li>
                                    <li><strong>Entry变成&lt;null, Value&gt;结构</strong>：Entry的key变为null，但value仍被强引用</li>
                                    <li><strong>线程长期存活</strong>：如果线程不结束（如线程池中的线程），value无法被回收</li>
                                    <li><strong>内存泄漏发生</strong>：value对象一直存在于ThreadLocalMap中，无法释放</li>
                                </ol>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">内存泄漏的具体示例：</h4>
                            <pre class="code-block">
public class MemoryLeakExample {
    private static final ThreadLocal&lt;byte[]&gt; threadLocal = new ThreadLocal&lt;&gt;();
    
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        for (int i = 0; i < 100; i++) {
            executor.submit(() -> {
                threadLocal.set(new byte[1024 * 1024]); // 1MB大对象
                // 业务处理...
                // 忘记调用threadLocal.remove()
            });
        }
        
        executor.shutdown();
    }
}</pre>
                            <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                                这个示例展示了线程池环境下的内存泄漏问题：每次任务创建1MB的字节数组，但由于没有调用remove()，这些大对象会一直保留在线程的ThreadLocalMap中，最终导致OOM（OutOfMemoryError）。
                            </p>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">JDK的自我清理机制（局限性）</h4>
                            <p class="mb-2">
                                ThreadLocalMap有一些自我清理机制，在set、get、remove等操作时会清理过期的Entry（key为null的Entry）：
                            </p>
                            <pre class="code-block">
private void set(ThreadLocal&lt;?&gt; key, Object value) {
    // ... 遍历过程中
    if (k == null) { // 发现过期Entry
        replaceStaleEntry(key, value, i); // 清理
    }
}</pre>
                            <div class="mt-4 bg-orange-50 dark:bg-orange-900/20 p-3 rounded-lg">
                                <p class="font-medium text-orange-800 dark:text-orange-300 mb-1">但这种清理机制有明显的局限性：</p>
                                <ul class="list-disc pl-5 space-y-1 text-sm">
                                    <li>被动触发（需调用set/get/remove）</li>
                                    <li>清理不彻底（仅清理当前探测路径上的过期Entry）</li>
                                    <li>线程复用时不会主动清理</li>
                                </ul>
                                <p class="mt-2 font-medium text-orange-800 dark:text-orange-300">
                                    因此，<strong>仅依靠JDK的自动清理机制是不够的，必须主动调用remove()方法</strong>。
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 四、ThreadLocal的典型应用场景 -->
            <section id="section-4" class="section-card">
                <h2 class="text-2xl font-bold text-primary mb-6 flex items-center">
                    <i class="fa fa-th-large mr-3"></i>四、ThreadLocal的典型应用场景
                </h2>

                <div id="section-4-1" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">4.1 数据库连接和事务管理</h3>
                    <p class="mb-4 leading-relaxed">
                        在多线程环境下管理数据库连接是ThreadLocal最经典的应用场景之一。通过ThreadLocal可以确保每个线程都有自己独立的数据库连接，避免连接被多线程共享导致的事务混乱。
                    </p>
                    
                    <div class="space-y-6 mb-4">
                        <div>
                            <h4 class="font-medium mb-2">数据库连接管理的实现原理：</h4>
                            <p class="mb-2">
                                每个线程通过ThreadLocal持有独立的数据库连接，确保线程安全。在涉及到数据库连接的嵌套调用场景中，ThreadLocal可以用来确保每个线程都有自己的数据库连接，避免连接共享带来的问题，保证事务的一致性。
                            </p>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">具体实现示例：</h4>
                            <pre class="code-block">
public class ConnectionManager {
    private static final ThreadLocal&lt;Connection&gt; connHolder = new ThreadLocal&lt;&gt;();
    
    public static Connection getConnection() throws SQLException {
        Connection conn = connHolder.get();
        if (conn == null || conn.isClosed()) {
            conn = DriverManager.getConnection(DB_URL);
            connHolder.set(conn);
        }
        return conn;
    }
    
    public static void closeConnection() throws SQLException {
        Connection conn = connHolder.get();
        if (conn != null) {
            conn.close();
            connHolder.remove(); // 关键的清理操作
        }
    }
}</pre>
                            <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                                这个示例展示了如何使用ThreadLocal管理数据库连接：
                            </p>
                            <ol class="list-decimal pl-5 mt-1 space-y-1 text-sm">
                                <li>每个线程首次调用getConnection()时创建连接</li>
                                <li>后续调用直接使用保存在ThreadLocal中的连接</li>
                                <li>连接使用完毕后调用closeConnection()关闭连接并清理ThreadLocal</li>
                            </ol>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">事务管理中的应用：</h4>
                            <p class="mb-2">
                                在Spring等框架中，ThreadLocal被广泛用于事务管理。Spring的事务管理通过ThreadLocal存储数据库连接，保证同一个事务中使用同一个数据库连接。
                            </p>
                            <pre class="code-block">
public class TransactionManager {
    private static final ThreadLocal&lt;Connection&gt; txHolder = new ThreadLocal&lt;&gt;();
    
    public static void beginTransaction() throws SQLException {
        Connection conn = getConnection();
        txHolder.set(conn);
        conn.setAutoCommit(false);
    }
    
    public static void commitTransaction() throws SQLException {
        Connection conn = txHolder.get();
        if (conn != null) {
            conn.commit();
            conn.setAutoCommit(true);
            txHolder.remove();
        }
    }
    
    public static void rollbackTransaction() throws SQLException {
        Connection conn = txHolder.get();
        if (conn != null) {
            conn.rollback();
            conn.setAutoCommit(true);
            txHolder.remove();
        }
    }
}</pre>
                        </div>
                    </div>
                </div>

                <div id="section-4-2" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">4.2 用户会话和上下文管理</h3>
                    <p class="mb-4 leading-relaxed">
                        在Web应用和分布式系统中，用户会话和上下文管理是ThreadLocal的另一个重要应用场景。
                    </p>
                    
                    <div class="space-y-6 mb-4">
                        <div>
                            <h4 class="font-medium mb-2">Web应用中的用户会话管理：</h4>
                            <p class="mb-2">
                                在Web框架中，ThreadLocal常用于存储当前请求的用户上下文，如用户ID、权限信息、语言环境等。每个HTTP请求由独立的线程处理，通过ThreadLocal可以轻松实现会话数据的线程隔离。
                            </p>
                            <pre class="code-block">
public class SessionContext {
    private static final ThreadLocal&lt;String&gt; userIdHolder = new ThreadLocal&lt;&gt;();
    private static final ThreadLocal&lt;String&gt; languageHolder = new ThreadLocal&lt;&gt;();
    
    public static void setUserId(String userId) {
        userIdHolder.set(userId);
    }
    
    public static String getUserId() {
        return userIdHolder.get();
    }
    
    public static void setLanguage(String language) {
        languageHolder.set(language);
    }
    
    public static String getLanguage() {
        return languageHolder.get();
    }
    
    public static void clear() {
        userIdHolder.remove();
        languageHolder.remove();
    }
}</pre>
                            
                            <p class="mt-4 mb-2">在Servlet过滤器或Spring拦截器中，可以在请求开始时设置用户信息，请求结束时清理：</p>
                            <pre class="code-block">
public class SessionFilter implements Filter {
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
        try {
            // 从请求中获取用户ID和语言信息
            String userId = request.getHeader("X-User-Id");
            String language = request.getHeader("X-Language");
            
            SessionContext.setUserId(userId);
            SessionContext.setLanguage(language);
            
            chain.doFilter(request, response);
        } finally {
            SessionContext.clear(); // 确保清理
        }
    }
}</pre>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">分布式系统中的请求上下文：</h4>
                            <p class="mb-2">
                                在微服务架构中，一个请求通常会穿越多个服务或线程。ThreadLocal常用于存储请求上下文信息，如用户认证信息、追踪日志ID等。
                            </p>
                            <pre class="code-block">
public class RequestContext {
    private static final ThreadLocal&lt;String&gt; traceIdHolder = new ThreadLocal&lt;&gt;();
    private static final ThreadLocal&lt;Map&lt;String, String&gt;&gt; headersHolder = new ThreadLocal&lt;&gt;();
    
    public static void setTraceId(String traceId) {
        traceIdHolder.set(traceId);
    }
    
    public static String getTraceId() {
        return traceIdHolder.get();
    }
    
    public static void setHeaders(Map&lt;String, String&gt; headers) {
        headersHolder.set(new HashMap&lt;&gt;(headers));
    }
    
    public static Map&lt;String, String&gt; getHeaders() {
        return headersHolder.get();
    }
}</pre>
                        </div>
                    </div>
                </div>

                <div id="section-4-3" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">4.3 日志追踪和链路监控</h3>
                    <p class="mb-4 leading-relaxed">
                        在分布式系统中，日志追踪是定位问题的关键。ThreadLocal在日志追踪中扮演着重要角色。
                    </p>
                    
                    <div class="space-y-6 mb-4">
                        <div>
                            <h4 class="font-medium mb-2">生成和传递追踪ID：</h4>
                            <p class="mb-2">
                                在分布式调用链中，为每个请求生成唯一的追踪ID，在日志中统一打印追踪ID，便于调试和追踪问题。
                            </p>
                            <pre class="code-block">
public class TraceIdGenerator {
    private static final ThreadLocal&lt;String&gt; traceIdHolder = new ThreadLocal&lt;&gt;();
    
    public static String generateTraceId() {
        String traceId = UUID.randomUUID().toString();
        traceIdHolder.set(traceId);
        return traceId;
    }
    
    public static String getTraceId() {
        String traceId = traceIdHolder.get();
        if (traceId == null) {
            traceId = generateTraceId();
        }
        return traceId;
    }
}</pre>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">日志记录器的集成：</h4>
                            <p class="mb-2">
                                在日志记录中，可以存储一些线程相关的上下文信息，例如线程ID、请求ID等，方便排查问题。通过为每个线程设置独立的日志上下文，日志信息更加清晰，便于开发者追踪每个线程的执行过程，快速定位问题。
                            </p>
                            <pre class="code-block">
public class LogContext {
    private static final ThreadLocal&lt;String&gt; traceId = new ThreadLocal&lt;&gt;();
    private static final ThreadLocal&lt;String&gt; userId = new ThreadLocal&lt;&gt;();
    
    public static void setTraceId(String traceId) {
        LogContext.traceId.set(traceId);
    }
    
    public static void setUserId(String userId) {
        LogContext.userId.set(userId);
    }
    
    public static String getLogMessagePrefix() {
        return String.format(
            "[traceId=%s, userId=%s, thread=%s]",
            traceId.get() != null ? traceId.get() : "N/A",
            userId.get() != null ? userId.get() : "N/A",
            Thread.currentThread().getName()
        );
    }
}</pre>
                            
                            <p class="mt-4 mb-2">使用示例：</p>
                            <pre class="code-block">
public class SomeService {
    public void someMethod() {
        String prefix = LogContext.getLogMessagePrefix();
        System.out.println(prefix + " 进入someMethod方法");
        
        // 业务逻辑...
        
        System.out.println(prefix + " 退出someMethod方法");
    }
}</pre>
                        </div>
                    </div>
                </div>

                <div id="section-4-4" class="mb-8">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">4.4 线程安全的工具类管理</h3>
                    <p class="mb-4 leading-relaxed">
                        许多工具类不是线程安全的，使用ThreadLocal可以让这些工具类在多线程环境下安全使用。
                    </p>
                    
                    <div class="space-y-6 mb-4">
                        <div>
                            <h4 class="font-medium mb-2">SimpleDateFormat的线程安全问题：</h4>
                            <p class="mb-2">
                                SimpleDateFormat是典型的非线程安全类。当线程池开启，提交大量任务时，每个线程都创建属于自己的SimpleDateFormat开销会很大，而且占用内存。使用synchronized加锁可以解决线程安全问题，但会发生阻塞，影响效率。
                            </p>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">使用ThreadLocal的解决方案：</h4>
                            <pre class="code-block">
public class DateFormatUtil {
    private static final ThreadLocal&lt;SimpleDateFormat&gt; dateFormatHolder = 
        ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
    
    public static String formatDate(Date date) {
        return dateFormatHolder.get().format(date);
    }
    
    public static Date parseDate(String dateStr) throws ParseException {
        return dateFormatHolder.get().parse(dateStr);
    }
}</pre>
                            
                            <div class="mt-4 bg-green-50 dark:bg-green-900/20 p-3 rounded-lg">
                                <h5 class="font-medium mb-2">这个方案的优势：</h5>
                                <ol class="list-decimal pl-5 space-y-1">
                                    <li>每个线程拥有独立的SimpleDateFormat实例</li>
                                    <li>避免了创建多个实例的内存开销</li>
                                    <li>避免了synchronized的性能开销</li>
                                    <li>保证了线程安全</li>
                                </ol>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">其他非线程安全类的应用：</h4>
                            <p class="mb-2">
                                除了SimpleDateFormat，类似的非线程安全类还包括：
                            </p>
                            <ul class="list-disc pl-5 space-y-1">
                                <li>Random类（线程安全版本为ThreadLocalRandom）</li>
                                <li>各种Parser类（如XMLParser、JSONParser）</li>
                                <li>一些第三方工具类</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div id="section-4-5">
                    <h3 class="text-xl font-semibold text-dark dark:text-light mb-4">4.5 避免方法参数的层层传递</h3>
                    <p class="mb-4 leading-relaxed">
                        在复杂的调用链中，经常需要传递一些上下文参数，使用ThreadLocal可以避免方法参数的层层传递。
                    </p>
                    
                    <div class="grid md:grid-cols-2 gap-6 mb-4">
                        <div>
                            <h4 class="font-medium mb-2">传统的参数传递方式：</h4>
                            <pre class="code-block">
public class TraditionalApproach {
    public void methodA(String param1, String context) {
        methodB(param1, context);
    }
    
    public void methodB(String param2, String context) {
        methodC(param2, context);
    }
    
    public void methodC(String param3, String context) {
        // 使用context参数
        System.out.println("context: " + context);
    }
}</pre>
                            <div class="mt-2 bg-red-50 dark:bg-red-900/20 p-2 rounded-lg text-sm">
                                <p class="font-medium text-red-800 dark:text-red-300 mb-1">这种方式的问题：</p>
                                <ol class="list-decimal pl-5 space-y-1">
                                    <li>方法签名变得复杂</li>
                                    <li>即使中间方法不需要context参数，也必须传递</li>
                                    <li>维护困难，容易出错</li>
                                </ol>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">使用ThreadLocal的改进方案：</h4>
                            <pre class="code-block">
public class ThreadLocalApproach {
    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();
    
    public void methodA(String param1) {
        contextHolder.set("上下文数据");
        methodB(param1);
    }
    
    public void methodB(String param2) {
        methodC(param2);
    }
    
    public void methodC(String param3) {
        String context = contextHolder.get();
        System.out.println("context: " + context);
    }
}</pre>
                            <div class="mt-2 bg-green-50 dark:bg-green-900/20 p-2 rounded-lg text-sm">
                                <p class="font-medium text-green-800 dark:text-green-300 mb-1">优势：</p>
                                <ol class="list-decimal pl-5 space-y-1">
                                    <li>方法签名简洁</li>
                                    <li>不需要在方法间传递上下文参数</li>
                                    <li>代码更清晰，维护成本低</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- 页脚 -->
    <footer class="bg-white dark:bg-gray-900 border-t border-gray-200 dark:border-gray-800 py-6 mt-12">
        <div class="container mx-auto px-4 text-center text-gray-600 dark:text-gray-400 text-sm">
            <p>© 2025 ThreadLocal 详解 | Java线程本地存储技术文档</p>
            <p class="mt-2">设计与开发：专业网页设计大师 | 基于Tailwind CSS构建</p>
        </div>
    </footer>

    <!-- 返回顶部按钮 -->
    <button id="back-to-top" class="fixed bottom-6 right-6 bg-primary text-white w-10 h-10 rounded-full flex items-center justify-center shadow-lg opacity-0 invisible transition-all duration-300 hover:bg-blue-700">
        <i class="fa fa-arrow-up"></i>
    </button>

    <!-- JavaScript -->
    <script>
        // DOM元素
        const sidebar = document.getElementById('sidebar');
        const mobileMenuBtn = document.getElementById('mobile-menu-btn');
        const themeToggle = document.getElementById('theme-toggle');
        const backToTopBtn = document.getElementById('back-to-top');
        const navItems = document.querySelectorAll('.nav-item');

        // 移动菜单切换
        mobileMenuBtn.addEventListener('click', () => {
            sidebar.classList.toggle('-translate-x-full');
            sidebar.classList.toggle('w-full');
        });

        // 主题切换
        function initTheme() {
            if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        }

        initTheme();

        themeToggle.addEventListener('click', () => {
            if (document.documentElement.classList.contains('dark')) {
                document.documentElement.classList.remove('dark');
                localStorage.theme = 'light';
            } else {
                document.documentElement.classList.add('dark');
                localStorage.theme = 'dark';
            }
        });

        // 返回顶部按钮
        window.addEventListener('scroll', () => {
            if (window.scrollY > 300) {
                backToTopBtn.classList.remove('opacity-0', 'invisible');
                backToTopBtn.classList.add('opacity-100', 'visible');
            } else {
                backToTopBtn.classList.add('opacity-0', 'invisible');
                backToTopBtn.classList.remove('opacity-100', 'visible');
            }
        });

        backToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // 导航菜单点击事件
        navItems.forEach(item => {
            item.addEventListener('click', () => {
                // 移除所有active类
                navItems.forEach(navItem => navItem.classList.remove('active'));
                // 给当前点击项添加active类
                item.classList.add('active');
                
                // 获取目标区域并滚动到视图
                const targetId = item.getAttribute('data-target');
                if (targetId) {
                    const targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        targetElement.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                        
                        // 在移动设备上点击导航后关闭菜单
                        if (window.innerWidth < 768) {
                            sidebar.classList.add('-translate-x-full');
                        }
                    }
                }
            });
        });

        // 初始化对比图表
        document.addEventListener('DOMContentLoaded', () => {
            const ctx = document.getElementById('comparisonChart').getContext('2d');
            
            new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['线程安全', '性能', '易用性', '内存效率', '适用场景广度'],
                    datasets: [
                        {
                            label: 'ThreadLocal',
                            data: [95, 90, 85, 70, 60],
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: 'rgba(59, 130, 246, 1)',
                            pointBackgroundColor: 'rgba(59, 130, 246, 1)',
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: 'rgba(59, 130, 246, 1)'
                        },
                        {
                            label: 'Synchronized',
                            data: [90, 60, 70, 95, 85],
                            backgroundColor: 'rgba(107, 114, 128, 0.2)',
                            borderColor: 'rgba(107, 114, 128, 1)',
                            pointBackgroundColor: 'rgba(107, 114, 128, 1)',
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: 'rgba(107, 114, 128, 1)'
                        }
                    ]
                },
                options: {
                    scales: {
                        r: {
                            angleLines: {
                                display: true
                            },
                            suggestedMin: 0,
                            suggestedMax: 100
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        title: {
                            display: true,
                            text: 'ThreadLocal vs Synchronized 对比'
                        }
                    }
                }
            });
        });

        // 代码块复制功能
        document.querySelectorAll('pre.code-block').forEach(block => {
            const copyBtn = document.createElement('button');
            copyBtn.className = 'absolute top-2 right-2 bg-gray-700 hover:bg-gray-600 text-white px-2 py-1 rounded text-xs transition-colors';
            copyBtn.innerHTML = '<i class="fa fa-copy mr-1"></i>复制';
            
            const preContainer = document.createElement('div');
            preContainer.className = 'relative';
            
            // 重新组织DOM结构
            block.parentNode.insertBefore(preContainer, block);
            preContainer.appendChild(block);
            preContainer.appendChild(copyBtn);
            
            // 复制功能
            copyBtn.addEventListener('click', () => {
                const code = block.textContent;
                navigator.clipboard.writeText(code).then(() => {
                    copyBtn.innerHTML = '<i class="fa fa-check mr-1"></i>已复制';
                    setTimeout(() => {
                        copyBtn.innerHTML = '<i class="fa fa-copy mr-1"></i>复制';
                    }, 2000);
                });
            });
        });
    </script>
</body>
</html>
