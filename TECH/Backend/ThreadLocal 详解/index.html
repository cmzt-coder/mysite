
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="CMZT的编程之路">
      
      
        <meta name="author" content="CMZT">
      
      
        <link rel="canonical" href="https://cmzt-coder.github.io/mysite/TECH/Backend/ThreadLocal%20%E8%AF%A6%E8%A7%A3/">
      
      
        <link rel="prev" href="../nodejs_express/">
      
      
        <link rel="next" href="../../AI/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.21">
    
    
      
        <title>ThreadLocal 详解 - CMZT——编程之路</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.2a3383ac.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css">
    
      <link rel="stylesheet" href="../../../mkdocs/css/no-footer.css">
    
      <link rel="stylesheet" href="../../../mkdocs/css/unordered-list-symbols.css">
    
      <link rel="stylesheet" href="../../../mkdocs/css/nav-style.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="orange">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#threadlocal" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="CMZT——编程之路" class="md-header__button md-logo" aria-label="CMZT——编程之路" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            CMZT——编程之路
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              ThreadLocal 详解
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="orange"  aria-label="切换至夜间模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换至夜间模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="orange"  aria-label="切换至日间模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换至日间模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/cmzt-coder/mysite" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.0.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    mysite
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../PROJECT/" class="md-tabs__link">
          
  
  
    
  
  项目

        </a>
      </li>
    
  

      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../" class="md-tabs__link">
          
  
  
    
  
  技术

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../INTERVIEW/" class="md-tabs__link">
          
  
  
    
  
  面试

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../ESSAY/" class="md-tabs__link">
          
  
  
    
  
  随笔

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../TEST/" class="md-tabs__link">
          
  
  
    
  
  测试

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../REPOST/" class="md-tabs__link">
          
  
  
    
  
  转载

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="CMZT——编程之路" class="md-nav__button md-logo" aria-label="CMZT——编程之路" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    CMZT——编程之路
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/cmzt-coder/mysite" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.0.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    mysite
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    首页
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../PROJECT/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    项目
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2" id="__nav_2_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            项目
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../PROJECT/web_search/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    网络资源搜索网站
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../PROJECT/sse_demo/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    SSE Demo
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    技术
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            技术
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3_2" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../Frontend/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    前端
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            前端
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Frontend/react_hooks/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    React Hooks使用指南
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Frontend/vue3_composition/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Vue3 Composition API详解
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" checked>
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    后端
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            后端
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../spring_boot_best_practices/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Spring Boot最佳实践
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../nodejs_express/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Node.js Express框架入门
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    ThreadLocal 详解
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    ThreadLocal 详解
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#threadlocal_1" class="md-nav__link">
    <span class="md-ellipsis">
      一、ThreadLocal 基本概念与核心特征
    </span>
  </a>
  
    <nav class="md-nav" aria-label="一、ThreadLocal 基本概念与核心特征">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-threadlocal" class="md-nav__link">
    <span class="md-ellipsis">
      1.1 什么是 ThreadLocal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    <span class="md-ellipsis">
      1.2 线程隔离性的实现原理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    <span class="md-ellipsis">
      1.3 与其他线程安全机制的对比
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#14-api" class="md-nav__link">
    <span class="md-ellipsis">
      1.4 基本 API 设计与核心方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#15-threadlocal" class="md-nav__link">
    <span class="md-ellipsis">
      1.5 ThreadLocal 的典型使用模式
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#threadlocal_2" class="md-nav__link">
    <span class="md-ellipsis">
      二、ThreadLocal 的使用方法详解
    </span>
  </a>
  
    <nav class="md-nav" aria-label="二、ThreadLocal 的使用方法详解">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-threadlocal" class="md-nav__link">
    <span class="md-ellipsis">
      2.1 创建和初始化 ThreadLocal 实例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22" class="md-nav__link">
    <span class="md-ellipsis">
      2.2 设置和获取线程局部变量
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-remove" class="md-nav__link">
    <span class="md-ellipsis">
      2.3 使用 remove () 方法清理资源
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24" class="md-nav__link">
    <span class="md-ellipsis">
      2.4 处理线程间数据传递问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25" class="md-nav__link">
    <span class="md-ellipsis">
      2.5 线程池环境下的特殊处理
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#threadlocal_3" class="md-nav__link">
    <span class="md-ellipsis">
      三、ThreadLocal 的运行原理深度剖析
    </span>
  </a>
  
    <nav class="md-nav" aria-label="三、ThreadLocal 的运行原理深度剖析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-threadthreadlocal-threadlocalmap" class="md-nav__link">
    <span class="md-ellipsis">
      3.1 核心存储结构：Thread、ThreadLocal 和 ThreadLocalMap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    <span class="md-ellipsis">
      3.2 数据读写的核心流程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    <span class="md-ellipsis">
      3.3 弱引用机制的设计原理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34" class="md-nav__link">
    <span class="md-ellipsis">
      3.4 哈希冲突的处理机制
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#35" class="md-nav__link">
    <span class="md-ellipsis">
      3.5 内存泄漏的产生机制与预防
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#threadlocal_4" class="md-nav__link">
    <span class="md-ellipsis">
      四、ThreadLocal 的典型应用场景
    </span>
  </a>
  
    <nav class="md-nav" aria-label="四、ThreadLocal 的典型应用场景">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41" class="md-nav__link">
    <span class="md-ellipsis">
      4.1 数据库连接和事务管理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    <span class="md-ellipsis">
      4.2 用户会话和上下文管理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43" class="md-nav__link">
    <span class="md-ellipsis">
      4.3 日志追踪和链路监控
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44" class="md-nav__link">
    <span class="md-ellipsis">
      4.4 线程安全的工具类管理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45" class="md-nav__link">
    <span class="md-ellipsis">
      4.5 避免方法参数的层层传递
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#threadlocal_5" class="md-nav__link">
    <span class="md-ellipsis">
      五、ThreadLocal 使用的最佳实践
    </span>
  </a>
  
    <nav class="md-nav" aria-label="五、ThreadLocal 使用的最佳实践">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    <span class="md-ellipsis">
      5.1 内存管理的最佳实践
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52" class="md-nav__link">
    <span class="md-ellipsis">
      5.2 线程池环境下的特殊处理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53" class="md-nav__link">
    <span class="md-ellipsis">
      5.3 性能优化策略
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#54" class="md-nav__link">
    <span class="md-ellipsis">
      5.4 代码规范和设计原则
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#55" class="md-nav__link">
    <span class="md-ellipsis">
      5.5 常见错误和陷阱
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      六、总结与展望
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3_4" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../AI/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    AI
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3_4" id="__nav_3_4_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_4">
            <span class="md-nav__icon md-icon"></span>
            AI
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../AI/machine_learning_basics/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    机器学习基础
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../AI/deep_learning_frameworks/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    深度学习框架对比
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_4" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../INTERVIEW/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    面试
    
  </span>
  

            </a>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            面试
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_5" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../ESSAY/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    随笔
    
  </span>
  

            </a>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            随笔
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_6" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../TEST/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    测试
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            测试
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../TEST/Canal%E9%9B%86%E6%88%90%E6%8C%87%E5%8D%97.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Canal集成指南
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ThreadLocal%20%E8%AF%A6%E8%A7%A3.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ThreadLocal 详解
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_7" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../REPOST/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    转载
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            转载
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../REPOST/clean_code_principles/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    编写整洁代码的十大原则
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../REPOST/git_workflow_guide/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Git工作流最佳实践指南
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#threadlocal_1" class="md-nav__link">
    <span class="md-ellipsis">
      一、ThreadLocal 基本概念与核心特征
    </span>
  </a>
  
    <nav class="md-nav" aria-label="一、ThreadLocal 基本概念与核心特征">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-threadlocal" class="md-nav__link">
    <span class="md-ellipsis">
      1.1 什么是 ThreadLocal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    <span class="md-ellipsis">
      1.2 线程隔离性的实现原理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    <span class="md-ellipsis">
      1.3 与其他线程安全机制的对比
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#14-api" class="md-nav__link">
    <span class="md-ellipsis">
      1.4 基本 API 设计与核心方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#15-threadlocal" class="md-nav__link">
    <span class="md-ellipsis">
      1.5 ThreadLocal 的典型使用模式
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#threadlocal_2" class="md-nav__link">
    <span class="md-ellipsis">
      二、ThreadLocal 的使用方法详解
    </span>
  </a>
  
    <nav class="md-nav" aria-label="二、ThreadLocal 的使用方法详解">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-threadlocal" class="md-nav__link">
    <span class="md-ellipsis">
      2.1 创建和初始化 ThreadLocal 实例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22" class="md-nav__link">
    <span class="md-ellipsis">
      2.2 设置和获取线程局部变量
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-remove" class="md-nav__link">
    <span class="md-ellipsis">
      2.3 使用 remove () 方法清理资源
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24" class="md-nav__link">
    <span class="md-ellipsis">
      2.4 处理线程间数据传递问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25" class="md-nav__link">
    <span class="md-ellipsis">
      2.5 线程池环境下的特殊处理
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#threadlocal_3" class="md-nav__link">
    <span class="md-ellipsis">
      三、ThreadLocal 的运行原理深度剖析
    </span>
  </a>
  
    <nav class="md-nav" aria-label="三、ThreadLocal 的运行原理深度剖析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-threadthreadlocal-threadlocalmap" class="md-nav__link">
    <span class="md-ellipsis">
      3.1 核心存储结构：Thread、ThreadLocal 和 ThreadLocalMap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    <span class="md-ellipsis">
      3.2 数据读写的核心流程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    <span class="md-ellipsis">
      3.3 弱引用机制的设计原理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34" class="md-nav__link">
    <span class="md-ellipsis">
      3.4 哈希冲突的处理机制
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#35" class="md-nav__link">
    <span class="md-ellipsis">
      3.5 内存泄漏的产生机制与预防
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#threadlocal_4" class="md-nav__link">
    <span class="md-ellipsis">
      四、ThreadLocal 的典型应用场景
    </span>
  </a>
  
    <nav class="md-nav" aria-label="四、ThreadLocal 的典型应用场景">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41" class="md-nav__link">
    <span class="md-ellipsis">
      4.1 数据库连接和事务管理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    <span class="md-ellipsis">
      4.2 用户会话和上下文管理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43" class="md-nav__link">
    <span class="md-ellipsis">
      4.3 日志追踪和链路监控
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44" class="md-nav__link">
    <span class="md-ellipsis">
      4.4 线程安全的工具类管理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45" class="md-nav__link">
    <span class="md-ellipsis">
      4.5 避免方法参数的层层传递
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#threadlocal_5" class="md-nav__link">
    <span class="md-ellipsis">
      五、ThreadLocal 使用的最佳实践
    </span>
  </a>
  
    <nav class="md-nav" aria-label="五、ThreadLocal 使用的最佳实践">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    <span class="md-ellipsis">
      5.1 内存管理的最佳实践
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52" class="md-nav__link">
    <span class="md-ellipsis">
      5.2 线程池环境下的特殊处理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53" class="md-nav__link">
    <span class="md-ellipsis">
      5.3 性能优化策略
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#54" class="md-nav__link">
    <span class="md-ellipsis">
      5.4 代码规范和设计原则
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#55" class="md-nav__link">
    <span class="md-ellipsis">
      5.5 常见错误和陷阱
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      六、总结与展望
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="threadlocal">一、ThreadLocal基本概念与核心特征<a class="headerlink" href="#threadlocal" title="Permanent link">&para;</a></h1>
<h2 id="threadlocal_1">一、ThreadLocal 基本概念与核心特征<a class="headerlink" href="#threadlocal_1" title="Permanent link">&para;</a></h2>
<h3 id="11-threadlocal">1.1 什么是 ThreadLocal<a class="headerlink" href="#11-threadlocal" title="Permanent link">&para;</a></h3>
<p><strong>ThreadLocal 是 Java 中用于实现线程本地存储的工具类</strong>，其核心功能是为每个线程创建独立的变量副本，避免多线程环境下的变量共享问题，从而简化线程安全编程<a href="https://blog.csdn.net/2301_81511613/article/details/148382684">(1)</a>。从官方文档的定义来看，ThreadLocal 提供线程局部变量，这些变量与普通变量的区别在于，<strong>每个访问该变量的线程（通过 get 或 set 方法）都有自己独立初始化的变量副本</strong><a href="http://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html">(21)</a>。</p>
<p>ThreadLocal 的核心思想可以用一个形象的比喻来理解：它就像每个线程的 "私人储物柜"，每个线程都有自己的独立空间，存进去的东西只有自己能拿到，其他线程看不见也摸不着。这种设计确保了线程间的数据隔离，使得每个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本<a href="https://www.cnblogs.com/xiaowangbangzhu/p/18874645">(3)</a>。</p>
<p>从技术实现角度看，<strong>ThreadLocal 是通过每个线程单独一份存储空间来实现线程隔离的</strong>，每个 ThreadLocal 只能保存一个变量副本<a href="https://juejin.cn/post/6915746638736818189">(25)</a>。这种设计与传统的共享变量加锁机制形成了鲜明对比，它采用 "空间换时间" 的策略，通过为每个线程创建独立副本，从根本上避免了线程间的竞争和同步开销。</p>
<h3 id="12">1.2 线程隔离性的实现原理<a class="headerlink" href="#12" title="Permanent link">&para;</a></h3>
<p>ThreadLocal 的线程隔离性基于其独特的存储架构。<strong>每个 Thread 对象内部都维护一个 ThreadLocal.ThreadLocalMap 类型的成员变量 threadLocals</strong><a href="https://www.cnblogs.com/xiaowangbangzhu/p/18874645">(3)</a>，这个 map 就是线程本地变量的存储容器。当线程通过 ThreadLocal 的 get () 或 set () 方法访问变量时，实际上操作的是该线程独有的数据，而不是全局共享的数据<a href="https://juejin.cn/post/7481580233646293018">(7)</a>。</p>
<p>这种隔离机制的实现具有以下特点：</p>
<p><strong>线程隔离性</strong>：每个线程对 ThreadLocal 变量的修改对其他线程是不可见的<a href="https://blog.csdn.net/weixin_47068446/article/details/140966262">(10)</a>。每个线程通过 ThreadLocalMap 存储自己的变量副本，实现线程隔离，线程对 ThreadLocal 变量的读写操作都局限在自己的 ThreadLocalMap 中，与其他线程完全隔离<a href="https://cloud.tencent.com/developer/article/2517742">(70)</a>。</p>
<p><strong>无锁设计</strong>：通过复制变量避免同步，性能优于锁机制。由于变量不共享，无需使用 synchronized 等同步机制，从根本上消除了线程间的竞争条件<a href="https://blog.csdn.net/NIIT0532/article/details/149348840">(9)</a>。</p>
<p><strong>内存效率</strong>：相比创建多个对象实例，ThreadLocal 通常更节省内存<a href="https://blog.csdn.net/NIIT0532/article/details/149348840">(9)</a>。它通过复用 ThreadLocal 实例，仅为每个线程创建必要的副本，避免了对象的重复创建。</p>
<h3 id="13">1.3 与其他线程安全机制的对比<a class="headerlink" href="#13" title="Permanent link">&para;</a></h3>
<p>ThreadLocal 与传统的线程安全机制（如 synchronized）在设计理念和应用场景上存在本质差异，理解这些差异对于正确使用 ThreadLocal 至关重要。</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>ThreadLocal</strong></th>
<th><strong>Synchronized</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>解决问题</strong></td>
<td>线程间数据隔离（空间换时间）</td>
<td>多线程访问共享资源的互斥（时间换空间）</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>每个线程独立副本，天然安全</td>
<td>通过锁机制保证原子性</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>数据需线程隔离（如会话信息）</td>
<td>共享资源的同步访问（如计数器）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>无锁，性能高</td>
<td>锁竞争可能导致性能下降</td>
</tr>
<tr>
<td><strong>复杂性</strong></td>
<td>简单，需关注内存管理</td>
<td>需设计锁策略，防止死锁</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>每个线程一份副本</td>
<td>共享一份数据</td>
</tr>
</tbody>
</table>
<p>从表格可以看出，<strong>ThreadLocal 适合线程独占数据的场景</strong>，如数据库连接、用户会话等，而 synchronized 适合共享资源访问的场景，如计数器、共享缓存。ThreadLocal 通过为每个线程提供独立副本，彻底避免了资源竞争，而 synchronized 则是在共享资源的基础上通过互斥机制保证线程安全。</p>
<h3 id="14-api">1.4 基本 API 设计与核心方法<a class="headerlink" href="#14-api" title="Permanent link">&para;</a></h3>
<p>ThreadLocal 提供了简洁而强大的 API，主要包括以下核心方法：</p>
<p><strong>构造方法</strong>：</p>
<ul>
<li><code>public ThreadLocal()</code>：创建一个线程本地变量</li>
</ul>
<p><strong>核心方法</strong>：</p>
<ul>
<li>
<p><code>public T get()</code>：返回当前线程的此线程局部变量副本中的值。如果该变量没有当前线程的值，将首先调用 initialValue () 方法进行初始化</p>
</li>
<li>
<p><code>protected T initialValue()</code>：返回当前线程的 "初始值"。该方法在第一次调用 get () 时被调用，除非线程之前调用过 set () 方法。默认实现返回 null</p>
</li>
<li>
<p><code>public void set(T value)</code>：将当前线程的此线程局部变量副本设置为指定值</p>
</li>
<li>
<p><code>public void remove()</code>：移除当前线程的此线程局部变量值。后续调用 get () 时，会重新调用 initialValue () 方法初始化，除非再次调用 set ()</p>
</li>
<li>
<p><code>public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier)</code>：创建一个带有初始值的线程局部变量，初始值由 Supplier 的 get () 方法确定。这是 Java 8 引入的新方法</p>
</li>
</ul>
<p>这些方法的设计体现了 ThreadLocal 的设计哲学：<strong>简单易用、功能专注</strong>。通过这几个核心方法，开发者可以轻松实现线程级别的数据隔离和管理。</p>
<h3 id="15-threadlocal">1.5 ThreadLocal 的典型使用模式<a class="headerlink" href="#15-threadlocal" title="Permanent link">&para;</a></h3>
<p>基于上述基本概念，ThreadLocal 的典型使用模式包括以下几种：</p>
<p><strong>独立副本模式</strong>：为每个线程创建独立的对象副本，如数据库连接、SimpleDateFormat 等线程不安全的对象。通过 ThreadLocal 为每个线程提供专属实例，避免线程安全问题。</p>
<p><strong>上下文传递模式</strong>：在复杂的调用链中传递上下文信息，如用户认证信息、请求 ID 等。通过 ThreadLocal 可以避免在方法参数中层层传递这些信息，提高代码的简洁性和可维护性。</p>
<p><strong>状态管理模式</strong>：在多线程环境下管理线程的执行状态，如事务上下文、任务进度等。每个线程可以独立维护自己的状态，互不干扰。</p>
<h2 id="threadlocal_2">二、ThreadLocal 的使用方法详解<a class="headerlink" href="#threadlocal_2" title="Permanent link">&para;</a></h2>
<h3 id="21-threadlocal">2.1 创建和初始化 ThreadLocal 实例<a class="headerlink" href="#21-threadlocal" title="Permanent link">&para;</a></h3>
<p>创建 ThreadLocal 实例是使用的第一步，根据不同的需求，有多种创建和初始化方式可供选择。</p>
<p><strong>基本创建方式</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-0-1">private static final ThreadLocal\&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();
</span></code></pre></div></td></tr></table></div>
<p>这是最基本的创建方式，创建了一个初始值为 null 的 ThreadLocal 实例。在实际使用中，建议使用<strong>static final 修饰符</strong>来声明 ThreadLocal 实例，这样做有两个好处：一是避免重复创建实例，节省内存；二是便于统一管理生命周期。</p>
<p><strong>提供初始值的方式</strong>：</p>
<ol>
<li><strong>重写 initialValue () 方法</strong>：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-1-1">private static final ThreadLocal\&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;() {
</span><span id="__span-1-2">
</span><span id="__span-1-3">    @Override
</span><span id="__span-1-4">
</span><span id="__span-1-5">    protected String initialValue() {
</span><span id="__span-1-6">
</span><span id="__span-1-7">        return &quot;默认值&quot;; // 线程首次调用get()时返回此值
</span><span id="__span-1-8">
</span><span id="__span-1-9">    }
</span><span id="__span-1-10">
</span><span id="__span-1-11">};
</span></code></pre></div></td></tr></table></div>
<ol>
<li><strong>使用 withInitial () 方法（Java 8+）</strong>：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-2-1">private static final ThreadLocal\&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; &quot;默认值&quot;);
</span></code></pre></div></td></tr></table></div>
<p>这两种方式都可以为 ThreadLocal 提供初始值，避免返回 null 导致的 NPE（NullPointerException）。withInitial () 方法是 Java 8 引入的新特性，它使用函数式接口 Supplier 来提供初始值，代码更加简洁优雅。</p>
<p><strong>泛型类型的使用</strong>：</p>
<p>ThreadLocal 支持泛型，使用时应尽量指定具体的类型，避免使用 Object 类型，这样可以减少类型转换的错误，也让代码更加清晰。例如：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-3-1">// 正确做法：指定具体类型
</span><span id="__span-3-2">
</span><span id="__span-3-3">ThreadLocal\&lt;String&gt; strThreadLocal = new ThreadLocal&lt;&gt;();
</span><span id="__span-3-4">
</span><span id="__span-3-5">// 错误做法：使用Object类型
</span><span id="__span-3-6">
</span><span id="__span-3-7">ThreadLocal\&lt;Object&gt; objThreadLocal = new ThreadLocal&lt;&gt;();
</span></code></pre></div></td></tr></table></div>
<h3 id="22">2.2 设置和获取线程局部变量<a class="headerlink" href="#22" title="Permanent link">&para;</a></h3>
<p>设置和获取线程局部变量是 ThreadLocal 的核心操作，这两个操作都具有线程隔离性。</p>
<p><strong>设置值（set 方法）</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-4-1">// 在当前线程中存储数据
</span><span id="__span-4-2">
</span><span id="__span-4-3">threadLocal.set(&quot;线程本地数据&quot;);
</span></code></pre></div></td></tr></table></div>
<p>set 方法将当前线程的 ThreadLocal 变量设置为指定值。<strong>需要注意的是，这个值只对当前线程可见</strong>，其他线程无法访问或修改这个值。</p>
<p><strong>获取值（get 方法）</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-5-1">// 在当前线程中获取数据
</span><span id="__span-5-2">
</span><span id="__span-5-3">String data = threadLocal.get();
</span></code></pre></div></td></tr></table></div>
<p>get 方法返回当前线程的 ThreadLocal 变量值。如果这是线程第一次调用 get () 方法，且之前没有调用过 set () 方法，则会调用 initialValue () 方法初始化并返回初始值。</p>
<p><strong>线程安全的使用示例</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-6-1">public class ThreadLocalExample {
</span><span id="__span-6-2">
</span><span id="__span-6-3">    private static final ThreadLocal\&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();
</span><span id="__span-6-4">
</span><span id="__span-6-5">    public static void main(String\[] args) {
</span><span id="__span-6-6">
</span><span id="__span-6-7">        Runnable task = () -&gt; {
</span><span id="__span-6-8">
</span><span id="__span-6-9">            // 设置当前线程的ID作为值
</span><span id="__span-6-10">
</span><span id="__span-6-11">            threadLocal.set(Thread.currentThread().getId());
</span><span id="__span-6-12">
</span><span id="__span-6-13">            System.out.println(Thread.currentThread().getName() + &quot;: &quot; + threadLocal.get());
</span><span id="__span-6-14">
</span><span id="__span-6-15">            threadLocal.remove(); // 清理
</span><span id="__span-6-16">
</span><span id="__span-6-17">        };
</span><span id="__span-6-18">
</span><span id="__span-6-19">        Thread t1 = new Thread(task, &quot;Thread-1&quot;);
</span><span id="__span-6-20">
</span><span id="__span-6-21">        Thread t2 = new Thread(task, &quot;Thread-2&quot;);
</span><span id="__span-6-22">
</span><span id="__span-6-23">        t1.start();
</span><span id="__span-6-24">
</span><span id="__span-6-25">        t2.start();
</span><span id="__span-6-26">
</span><span id="__span-6-27">    }
</span><span id="__span-6-28">
</span><span id="__span-6-29">}
</span></code></pre></div></td></tr></table></div>
<p>输出结果：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-7-1">Thread-1: 10
</span><span id="__span-7-2">
</span><span id="__span-7-3">Thread-2: 11
</span></code></pre></div></td></tr></table></div>
<p>这个示例展示了每个线程如何独立地设置和获取自己的 ThreadLocal 值，体现了线程隔离的特性。</p>
<h3 id="23-remove">2.3 使用 remove () 方法清理资源<a class="headerlink" href="#23-remove" title="Permanent link">&para;</a></h3>
<p><strong>remove () 方法是防止内存泄漏的关键</strong>，必须正确使用。remove () 方法用于移除当前线程的 ThreadLocal 变量值，后续调用 get () 时会重新调用 initialValue () 方法初始化，除非再次调用 set () 方法。</p>
<p>在以下场景中必须调用 remove () 方法：</p>
<ol>
<li><strong>使用 try-finally 块确保清理</strong>：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-8-1">try {
</span><span id="__span-8-2">
</span><span id="__span-8-3">    threadLocal.set(value);
</span><span id="__span-8-4">
</span><span id="__span-8-5">    // 业务逻辑...
</span><span id="__span-8-6">
</span><span id="__span-8-7">} finally {
</span><span id="__span-8-8">
</span><span id="__span-8-9">    threadLocal.remove(); // 就像用完厕所要冲水！
</span><span id="__span-8-10">
</span><span id="__span-8-11">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li><strong>线程池环境下的清理</strong>：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-9-1">ExecutorService executor = Executors.newFixedThreadPool(2);
</span><span id="__span-9-2">
</span><span id="__span-9-3">executor.submit(() -&gt; {
</span><span id="__span-9-4">
</span><span id="__span-9-5">    try {
</span><span id="__span-9-6">
</span><span id="__span-9-7">        threadLocal.set(value);
</span><span id="__span-9-8">
</span><span id="__span-9-9">        // 任务逻辑
</span><span id="__span-9-10">
</span><span id="__span-9-11">    } finally {
</span><span id="__span-9-12">
</span><span id="__span-9-13">        threadLocal.remove(); // 必须清理！
</span><span id="__span-9-14">
</span><span id="__span-9-15">    }
</span><span id="__span-9-16">
</span><span id="__span-9-17">});
</span></code></pre></div></td></tr></table></div>
<p><strong>为什么必须调用 remove ()？</strong> 原因有两个：一是线程池中的线程会被重用，不 remove 会导致上次的数据残留（内存泄漏 + 脏数据）；二是避免 ThreadLocalMap 中积累无效的 Entry，导致内存泄漏。</p>
<h3 id="24">2.4 处理线程间数据传递问题<a class="headerlink" href="#24" title="Permanent link">&para;</a></h3>
<p>ThreadLocal 的一个重要特性是<strong>数据仅在当前线程可见</strong>，即使子线程也无法访问父线程的本地变量。这是 ThreadLocal 设计的基本原则，但在某些场景下可能需要父子线程间的数据传递。</p>
<p><strong>默认情况下父子线程无法共享数据</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-10-1">ThreadLocal\&lt;String&gt; parentData = new ThreadLocal&lt;&gt;();
</span><span id="__span-10-2">
</span><span id="__span-10-3">parentData.set(&quot;父线程数据&quot;);
</span><span id="__span-10-4">
</span><span id="__span-10-5">new Thread(() -&gt; {
</span><span id="__span-10-6">
</span><span id="__span-10-7">    // 这里获取不到parentData的值！
</span><span id="__span-10-8">
</span><span id="__span-10-9">    System.out.println(&quot;子线程获取到的数据：&quot; + parentData.get());
</span><span id="__span-10-10">
</span><span id="__span-10-11">}).start();
</span></code></pre></div></td></tr></table></div>
<p>输出结果：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-11-1">子线程获取到的数据：null
</span></code></pre></div></td></tr></table></div>
<p><strong>解决方案：使用 InheritableThreadLocal</strong>：</p>
<p>如果需要父子线程间传递数据，可以使用 InheritableThreadLocal，它是 ThreadLocal 的子类，允许子线程继承父线程的 ThreadLocal 值。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-12-1">InheritableThreadLocal\&lt;String&gt; inheritableThreadLocal = new InheritableThreadLocal&lt;&gt;();
</span><span id="__span-12-2">
</span><span id="__span-12-3">inheritableThreadLocal.set(&quot;父线程数据&quot;);
</span><span id="__span-12-4">
</span><span id="__span-12-5">new Thread(() -&gt; {
</span><span id="__span-12-6">
</span><span id="__span-12-7">    // 子线程可以获取到父线程的数据
</span><span id="__span-12-8">
</span><span id="__span-12-9">    System.out.println(&quot;子线程获取到的数据：&quot; + inheritableThreadLocal.get());
</span><span id="__span-12-10">
</span><span id="__span-12-11">}).start();
</span></code></pre></div></td></tr></table></div>
<p>输出结果：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-13-1">子线程获取到的数据：父线程数据
</span></code></pre></div></td></tr></table></div>
<p>但需要注意的是，InheritableThreadLocal 也有一些限制和风险：一是可能导致内存泄漏，因为子线程可能持有父线程的数据引用；二是如果修改了共享对象的属性，会影响到父线程的数据。因此，使用时需要谨慎。</p>
<h3 id="25">2.5 线程池环境下的特殊处理<a class="headerlink" href="#25" title="Permanent link">&para;</a></h3>
<p>线程池环境下使用 ThreadLocal 需要特别小心，因为线程池中的线程会被重用，可能导致数据污染和内存泄漏。</p>
<p><strong>线程池中的数据残留问题</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-14-1">public class ThreadPoolIssue {
</span><span id="__span-14-2">
</span><span id="__span-14-3">    private static final ThreadLocal\&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();
</span><span id="__span-14-4">
</span><span id="__span-14-5">    public static void main(String\[] args) {
</span><span id="__span-14-6">
</span><span id="__span-14-7">        ExecutorService executor = Executors.newFixedThreadPool(1);
</span><span id="__span-14-8">
</span><span id="__span-14-9">        executor.submit(() -&gt; {
</span><span id="__span-14-10">
</span><span id="__span-14-11">            threadLocal.set(&quot;Task1&quot;);
</span><span id="__span-14-12">
</span><span id="__span-14-13">            System.out.println(&quot;任务1：&quot; + threadLocal.get()); // 输出 Task1
</span><span id="__span-14-14">
</span><span id="__span-14-15">        });
</span><span id="__span-14-16">
</span><span id="__span-14-17">        executor.submit(() -&gt; {
</span><span id="__span-14-18">
</span><span id="__span-14-19">            System.out.println(&quot;任务2：&quot; + threadLocal.get()); // 输出 Task1（数据污染）
</span><span id="__span-14-20">
</span><span id="__span-14-21">        });
</span><span id="__span-14-22">
</span><span id="__span-14-23">        executor.shutdown();
</span><span id="__span-14-24">
</span><span id="__span-14-25">    }
</span><span id="__span-14-26">
</span><span id="__span-14-27">}
</span></code></pre></div></td></tr></table></div>
<p>这个示例展示了线程池环境下的典型问题：第二个任务获取到了第一个任务设置的数据，这就是数据污染。</p>
<p><strong>正确的处理方式</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-15-1">executor.submit(() -&gt; {
</span><span id="__span-15-2">
</span><span id="__span-15-3">    try {
</span><span id="__span-15-4">
</span><span id="__span-15-5">        threadLocal.set(&quot;Task2&quot;);
</span><span id="__span-15-6">
</span><span id="__span-15-7">        System.out.println(&quot;任务2：&quot; + threadLocal.get());
</span><span id="__span-15-8">
</span><span id="__span-15-9">    } finally {
</span><span id="__span-15-10">
</span><span id="__span-15-11">        threadLocal.remove(); // 必须清理
</span><span id="__span-15-12">
</span><span id="__span-15-13">    }
</span><span id="__span-15-14">
</span><span id="__span-15-15">});
</span></code></pre></div></td></tr></table></div>
<p><strong>最佳实践</strong>：</p>
<ol>
<li>
<p><strong>始终在 finally 块中调用 remove () 方法</strong></p>
</li>
<li>
<p>在线程池环境下格外小心</p>
</li>
<li>
<p>每次任务开始执行前最好都通过 set () 方法设置正确的 ThreadLocal 变量值，确保不会因为线程复用而出现数据混乱<a href="https://www.cnblogs.com/use-D/p/18224878">(71)</a></p>
</li>
</ol>
<h2 id="threadlocal_3">三、ThreadLocal 的运行原理深度剖析<a class="headerlink" href="#threadlocal_3" title="Permanent link">&para;</a></h2>
<h3 id="31-threadthreadlocal-threadlocalmap">3.1 核心存储结构：Thread、ThreadLocal 和 ThreadLocalMap<a class="headerlink" href="#31-threadthreadlocal-threadlocalmap" title="Permanent link">&para;</a></h3>
<p>要深入理解 ThreadLocal 的运行原理，首先需要了解其核心存储结构。ThreadLocal 的实现基于三个关键组件的协作：<strong>Thread</strong>、<strong>ThreadLocal</strong>和<strong>ThreadLocalMap</strong>。</p>
<p><strong>Thread 类中的关键变量</strong>：</p>
<p>每个 Thread 对象内部都维护一个 ThreadLocal.ThreadLocalMap 类型的成员变量 threadLocals，这个变量就是线程本地变量的存储容器<a href="https://www.cnblogs.com/xiaowangbangzhu/p/18874645">(3)</a>。在 Thread 类的源码中可以看到：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-16-1">public class Thread implements Runnable {
</span><span id="__span-16-2">
</span><span id="__span-16-3">    ThreadLocal.ThreadLocalMap threadLocals = null;
</span><span id="__span-16-4">
</span><span id="__span-16-5">    // 其他代码...
</span><span id="__span-16-6">
</span><span id="__span-16-7">}
</span></code></pre></div></td></tr></table></div>
<p>这个设计的核心思想是：<strong>每个线程拥有自己的 ThreadLocalMap，用于存储该线程的所有 ThreadLocal 变量</strong>。这种设计确保了线程间的数据隔离，每个线程只能访问自己的 ThreadLocalMap，无法访问其他线程的。</p>
<p><strong>ThreadLocalMap 的结构</strong>：</p>
<p>ThreadLocalMap 是 ThreadLocal 的静态内部类，它本质上是一个定制化的哈希表<a href="https://blog.51cto.com/zhangxueliang/9964398">(53)</a>。其核心结构如下：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-17-1">static class ThreadLocalMap {
</span><span id="__span-17-2">
</span><span id="__span-17-3">    static class Entry extends WeakReference\&lt;ThreadLocal\&lt;?&gt;&gt; {
</span><span id="__span-17-4">
</span><span id="__span-17-5">        Object value;
</span><span id="__span-17-6">
</span><span id="__span-17-7">        Entry(ThreadLocal\&lt;?&gt; k, Object v) {
</span><span id="__span-17-8">
</span><span id="__span-17-9">            super(k);
</span><span id="__span-17-10">
</span><span id="__span-17-11">            value = v;
</span><span id="__span-17-12">
</span><span id="__span-17-13">        }
</span><span id="__span-17-14">
</span><span id="__span-17-15">    }
</span><span id="__span-17-16">
</span><span id="__span-17-17">
</span><span id="__span-17-18">
</span><span id="__span-17-19">    private Entry\[] table;
</span><span id="__span-17-20">
</span><span id="__span-17-21">    // 其他代码...
</span><span id="__span-17-22">
</span><span id="__span-17-23">}
</span></code></pre></div></td></tr></table></div>
<p>这里有两个关键要点：</p>
<ol>
<li>
<p><strong>Entry 继承自 WeakReference\&lt;ThreadLocal\&lt;?&gt;&gt;</strong>，这意味着 Entry 的 key（ThreadLocal 实例）是弱引用</p>
</li>
<li>
<p><strong>每个 Entry 存储一个键值对</strong>，key 是 ThreadLocal 实例，value 是线程本地变量的值</p>
</li>
</ol>
<p><strong>存储关系的完整视图</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-18-1">线程Thread
</span><span id="__span-18-2">
</span><span id="__span-18-3">  ↳ threadLocals（ThreadLocalMap类型）
</span><span id="__span-18-4">
</span><span id="__span-18-5">      ↳ table（Entry数组）
</span><span id="__span-18-6">
</span><span id="__span-18-7">          ↳ Entry（key=ThreadLocal实例（弱引用），value=线程本地变量）
</span></code></pre></div></td></tr></table></div>
<h3 id="32">3.2 数据读写的核心流程<a class="headerlink" href="#32" title="Permanent link">&para;</a></h3>
<p>理解 ThreadLocal 的工作原理，关键在于理解数据读写的具体流程。</p>
<p><strong>set (T value) 方法的执行流程</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-19-1">public void set(T value) {
</span><span id="__span-19-2">
</span><span id="__span-19-3">    Thread t = Thread.currentThread();
</span><span id="__span-19-4">
</span><span id="__span-19-5">    ThreadLocalMap map = getMap(t);
</span><span id="__span-19-6">
</span><span id="__span-19-7">    if (map != null) {
</span><span id="__span-19-8">
</span><span id="__span-19-9">        map.set(this, value); // 使用当前ThreadLocal实例作为Key
</span><span id="__span-19-10">
</span><span id="__span-19-11">    } else {
</span><span id="__span-19-12">
</span><span id="__span-19-13">        createMap(t, value);
</span><span id="__span-19-14">
</span><span id="__span-19-15">    }
</span><span id="__span-19-16">
</span><span id="__span-19-17">}
</span></code></pre></div></td></tr></table></div>
<p>流程分析：</p>
<ol>
<li>
<p>获取当前线程 t</p>
</li>
<li>
<p>获取线程 t 的 ThreadLocalMap（threadLocals）</p>
</li>
<li>
<p>如果 map 不为 null，调用 map.set (this, value)，这里使用当前 ThreadLocal 实例作为 key</p>
</li>
<li>
<p>如果 map 为 null，创建新的 ThreadLocalMap 并设置初始值</p>
</li>
</ol>
<p><strong>get () 方法的执行流程</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-20-1">public T get() {
</span><span id="__span-20-2">
</span><span id="__span-20-3">    Thread t = Thread.currentThread();
</span><span id="__span-20-4">
</span><span id="__span-20-5">    ThreadLocalMap map = getMap(t);
</span><span id="__span-20-6">
</span><span id="__span-20-7">    if (map != null) {
</span><span id="__span-20-8">
</span><span id="__span-20-9">        ThreadLocalMap.Entry e = map.getEntry(this);
</span><span id="__span-20-10">
</span><span id="__span-20-11">        if (e != null) {
</span><span id="__span-20-12">
</span><span id="__span-20-13">            @SuppressWarnings(&quot;unchecked&quot;)
</span><span id="__span-20-14">
</span><span id="__span-20-15">            T result = (T)e.value;
</span><span id="__span-20-16">
</span><span id="__span-20-17">            return result;
</span><span id="__span-20-18">
</span><span id="__span-20-19">        }
</span><span id="__span-20-20">
</span><span id="__span-20-21">    }
</span><span id="__span-20-22">
</span><span id="__span-20-23">    return setInitialValue();
</span><span id="__span-20-24">
</span><span id="__span-20-25">}
</span></code></pre></div></td></tr></table></div>
<p>流程分析：</p>
<ol>
<li>
<p>获取当前线程 t</p>
</li>
<li>
<p>获取线程 t 的 ThreadLocalMap</p>
</li>
<li>
<p>如果 map 不为 null，调用 map.getEntry (this) 查找对应的 Entry</p>
</li>
<li>
<p>如果找到 Entry，返回其 value</p>
</li>
<li>
<p>如果 map 为 null 或未找到 Entry，调用 setInitialValue () 初始化并返回初始值</p>
</li>
</ol>
<p><strong>createMap 方法</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-21-1">void createMap(Thread t, T firstValue) {
</span><span id="__span-21-2">
</span><span id="__span-21-3">    t.threadLocals = new ThreadLocalMap(this, firstValue);
</span><span id="__span-21-4">
</span><span id="__span-21-5">}
</span></code></pre></div></td></tr></table></div>
<p>createMap 方法会创建一个新的 ThreadLocalMap，并将当前 ThreadLocal 实例和初始值作为第一个 Entry 存入。</p>
<h3 id="33">3.3 弱引用机制的设计原理<a class="headerlink" href="#33" title="Permanent link">&para;</a></h3>
<p>ThreadLocalMap 中使用弱引用是一个关键的设计决策，理解这个设计对于正确使用 ThreadLocal 至关重要。</p>
<p><strong>为什么使用弱引用？</strong></p>
<p>ThreadLocalMap 的 Entry 使用弱引用指向 ThreadLocal 实例，这是为了防止内存泄漏。假设 Entry 使用强引用：</p>
<ul>
<li>
<p>如果外部强引用（如 userContext 变量）被置为 null</p>
</li>
<li>
<p>但 ThreadLocalMap 的 key 仍强引用 ThreadLocal 对象</p>
</li>
<li>
<p>导致 ThreadLocal 对象永远无法被回收，造成内存泄漏</p>
</li>
</ul>
<p>使用弱引用的设计是 "最后一道防线"：当外部强引用消失后，下次 GC 会回收 ThreadLocal 对象。这样可以避免 ThreadLocal 对象本身的泄漏。</p>
<p><strong>弱引用带来的问题</strong></p>
<p>然而，弱引用机制并不能完全解决内存泄漏问题，它只是解决了 ThreadLocal 对象本身的泄漏。如果线程长期存活（如线程池中的线程），且没有调用 remove () 方法，仍然会导致内存泄漏，因为：</p>
<ol>
<li>
<p>ThreadLocal 对象被 GC 回收，Entry 的 key 变为 null</p>
</li>
<li>
<p>但 Entry 的 value 仍被线程的 ThreadLocalMap 强引用</p>
</li>
<li>
<p>如果线程不结束，value 永远无法被回收</p>
</li>
</ol>
<h3 id="34">3.4 哈希冲突的处理机制<a class="headerlink" href="#34" title="Permanent link">&para;</a></h3>
<p>ThreadLocalMap 使用开放地址法（线性探测）来解决哈希冲突<a href="https://cloud.tencent.com/developer/article/2506222">(37)</a>，这种设计与 HashMap 的链表法不同，具有独特的特点。</p>
<p><strong>set 操作中的哈希冲突处理</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-22-1">private void set(ThreadLocal\&lt;?&gt; key, Object value) {
</span><span id="__span-22-2">
</span><span id="__span-22-3">    Entry\[] tab = table;
</span><span id="__span-22-4">
</span><span id="__span-22-5">    int len = tab.length;
</span><span id="__span-22-6">
</span><span id="__span-22-7">    int i = key.threadLocalHashCode &amp; (len-1);
</span><span id="__span-22-8">
</span><span id="__span-22-9">
</span><span id="__span-22-10">
</span><span id="__span-22-11">    for (Entry e = tab\[i]; e != null; e = tab\[i = nextIndex(i, len)]) {
</span><span id="__span-22-12">
</span><span id="__span-22-13">        ThreadLocal\&lt;?&gt; k = e.get();
</span><span id="__span-22-14">
</span><span id="__span-22-15">
</span><span id="__span-22-16">
</span><span id="__span-22-17">        if (k == key) {
</span><span id="__span-22-18">
</span><span id="__span-22-19">            e.value = value;
</span><span id="__span-22-20">
</span><span id="__span-22-21">            return;
</span><span id="__span-22-22">
</span><span id="__span-22-23">        }
</span><span id="__span-22-24">
</span><span id="__span-22-25">
</span><span id="__span-22-26">
</span><span id="__span-22-27">        if (k == null) {
</span><span id="__span-22-28">
</span><span id="__span-22-29">            replaceStaleEntry(key, value, i);
</span><span id="__span-22-30">
</span><span id="__span-22-31">            return;
</span><span id="__span-22-32">
</span><span id="__span-22-33">        }
</span><span id="__span-22-34">
</span><span id="__span-22-35">    }
</span><span id="__span-22-36">
</span><span id="__span-22-37">
</span><span id="__span-22-38">
</span><span id="__span-22-39">    tab\[i] = new Entry(key, value);
</span><span id="__span-22-40">
</span><span id="__span-22-41">    int sz = ++size;
</span><span id="__span-22-42">
</span><span id="__span-22-43">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
</span><span id="__span-22-44">
</span><span id="__span-22-45">        rehash();
</span><span id="__span-22-46">
</span><span id="__span-22-47">}
</span></code></pre></div></td></tr></table></div>
<p>处理流程：</p>
<ol>
<li>
<p>计算初始哈希索引 i = key.threadLocalHashCode &amp; (len-1)</p>
</li>
<li>
<p>如果 tab [i] 不为 null，说明发生冲突，使用线性探测寻找下一个空位</p>
</li>
<li>
<p>循环检查每个位置：</p>
</li>
<li>
<p>如果找到 key 相同的 Entry，更新 value</p>
</li>
<li>
<p>如果找到 key 为 null 的 Entry（即过期 Entry），调用 replaceStaleEntry 方法处理</p>
</li>
<li>
<p>如果找到空位，创建新的 Entry</p>
</li>
</ol>
<p><strong>get 操作中的哈希冲突处理</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-23-1">private Entry getEntry(ThreadLocal\&lt;?&gt; key) {
</span><span id="__span-23-2">
</span><span id="__span-23-3">    int i = key.threadLocalHashCode &amp; (table.length - 1);
</span><span id="__span-23-4">
</span><span id="__span-23-5">    Entry e = table\[i];
</span><span id="__span-23-6">
</span><span id="__span-23-7">    if (e != null &amp;&amp; e.get() == key)
</span><span id="__span-23-8">
</span><span id="__span-23-9">        return e;
</span><span id="__span-23-10">
</span><span id="__span-23-11">    else
</span><span id="__span-23-12">
</span><span id="__span-23-13">        return getEntryAfterMiss(key, i, e);
</span><span id="__span-23-14">
</span><span id="__span-23-15">}
</span></code></pre></div></td></tr></table></div>
<p>如果初始位置的 Entry 不是目标 Entry，会调用 getEntryAfterMiss 方法进行线性探测，直到找到目标 Entry 或遇到 null。</p>
<h3 id="35">3.5 内存泄漏的产生机制与预防<a class="headerlink" href="#35" title="Permanent link">&para;</a></h3>
<p>内存泄漏是使用 ThreadLocal 时最需要关注的问题，理解其产生机制对于正确使用至关重要。</p>
<p><strong>内存泄漏的产生路径</strong>：</p>
<ol>
<li>
<p><strong>外部强引用消失</strong>：当保存 ThreadLocal 引用的变量（如 userContext）被置为 null</p>
</li>
<li>
<p><strong>ThreadLocal 对象被 GC 回收</strong>：由于 Entry 使用弱引用，ThreadLocal 对象会被垃圾回收</p>
</li>
<li>
<p><strong>Entry 变成 \<null, Value> 结构</strong>：Entry 的 key 变为 null，但 value 仍被强引用</p>
</li>
<li>
<p><strong>线程长期存活</strong>：如果线程不结束（如线程池中的线程），value 无法被回收</p>
</li>
<li>
<p><strong>内存泄漏发生</strong>：value 对象一直存在于 ThreadLocalMap 中，无法释放</p>
</li>
</ol>
<p><strong>内存泄漏的具体示例</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-24-1">public class MemoryLeakExample {
</span><span id="__span-24-2">
</span><span id="__span-24-3">    private static final ThreadLocal\&lt;byte\[]&gt; threadLocal = new ThreadLocal&lt;&gt;();
</span><span id="__span-24-4">
</span><span id="__span-24-5">
</span><span id="__span-24-6">
</span><span id="__span-24-7">    public static void main(String\[] args) {
</span><span id="__span-24-8">
</span><span id="__span-24-9">        ExecutorService executor = Executors.newFixedThreadPool(2);
</span><span id="__span-24-10">
</span><span id="__span-24-11">
</span><span id="__span-24-12">
</span><span id="__span-24-13">        for (int i = 0; i &lt; 100; i++) {
</span><span id="__span-24-14">
</span><span id="__span-24-15">            executor.submit(() -&gt; {
</span><span id="__span-24-16">
</span><span id="__span-24-17">                threadLocal.set(new byte\[1024 \* 1024]); // 1MB大对象
</span><span id="__span-24-18">
</span><span id="__span-24-19">                // 业务处理...
</span><span id="__span-24-20">
</span><span id="__span-24-21">                // 忘记调用threadLocal.remove()
</span><span id="__span-24-22">
</span><span id="__span-24-23">            });
</span><span id="__span-24-24">
</span><span id="__span-24-25">        }
</span><span id="__span-24-26">
</span><span id="__span-24-27">
</span><span id="__span-24-28">
</span><span id="__span-24-29">        executor.shutdown();
</span><span id="__span-24-30">
</span><span id="__span-24-31">    }
</span><span id="__span-24-32">
</span><span id="__span-24-33">}
</span></code></pre></div></td></tr></table></div>
<p>这个示例展示了线程池环境下的内存泄漏问题：每次任务创建 1MB 的字节数组，但由于没有调用 remove ()，这些大对象会一直保留在线程的 ThreadLocalMap 中，最终导致 OOM（OutOfMemoryError）。</p>
<p><strong>JDK 的自我清理机制（局限性）</strong></p>
<p>ThreadLocalMap 有一些自我清理机制，在 set、get、remove 等操作时会清理过期的 Entry（key 为 null 的 Entry）：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-25-1">private void set(ThreadLocal\&lt;?&gt; key, Object value) {
</span><span id="__span-25-2">
</span><span id="__span-25-3">    // ... 遍历过程中
</span><span id="__span-25-4">
</span><span id="__span-25-5">    if (k == null) { // 发现过期Entry
</span><span id="__span-25-6">
</span><span id="__span-25-7">        replaceStaleEntry(key, value, i); // 清理
</span><span id="__span-25-8">
</span><span id="__span-25-9">    }
</span><span id="__span-25-10">
</span><span id="__span-25-11">}
</span></code></pre></div></td></tr></table></div>
<p>但这种清理机制有明显的局限性：</p>
<ul>
<li>
<p>被动触发（需调用 set/get/remove）</p>
</li>
<li>
<p>清理不彻底（仅清理当前探测路径上的过期 Entry）</p>
</li>
<li>
<p>线程复用时不会主动清理</p>
</li>
</ul>
<p>因此，<strong>仅依靠 JDK 的自动清理机制是不够的，必须主动调用 remove () 方法</strong>。</p>
<h2 id="threadlocal_4">四、ThreadLocal 的典型应用场景<a class="headerlink" href="#threadlocal_4" title="Permanent link">&para;</a></h2>
<h3 id="41">4.1 数据库连接和事务管理<a class="headerlink" href="#41" title="Permanent link">&para;</a></h3>
<p>在多线程环境下管理数据库连接是 ThreadLocal 最经典的应用场景之一。通过 ThreadLocal 可以确保每个线程都有自己独立的数据库连接，避免连接被多线程共享导致的事务混乱。</p>
<p><strong>数据库连接管理的实现原理</strong>：</p>
<p>每个线程通过 ThreadLocal 持有独立的数据库连接，确保线程安全。在涉及到数据库连接的嵌套调用场景中，ThreadLocal 可以用来确保每个线程都有自己的数据库连接，避免连接共享带来的问题，保证事务的一致性<a href="https://developer.aliyun.com/article/1661553">(59)</a>。</p>
<p><strong>具体实现示例</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-26-1">public class ConnectionManager {
</span><span id="__span-26-2">
</span><span id="__span-26-3">    private static final ThreadLocal\&lt;Connection&gt; connHolder = new ThreadLocal&lt;&gt;();
</span><span id="__span-26-4">
</span><span id="__span-26-5">
</span><span id="__span-26-6">
</span><span id="__span-26-7">    public static Connection getConnection() throws SQLException {
</span><span id="__span-26-8">
</span><span id="__span-26-9">        Connection conn = connHolder.get();
</span><span id="__span-26-10">
</span><span id="__span-26-11">        if (conn == null || conn.isClosed()) {
</span><span id="__span-26-12">
</span><span id="__span-26-13">            conn = DriverManager.getConnection(DB\_URL);
</span><span id="__span-26-14">
</span><span id="__span-26-15">            connHolder.set(conn);
</span><span id="__span-26-16">
</span><span id="__span-26-17">        }
</span><span id="__span-26-18">
</span><span id="__span-26-19">        return conn;
</span><span id="__span-26-20">
</span><span id="__span-26-21">    }
</span><span id="__span-26-22">
</span><span id="__span-26-23">
</span><span id="__span-26-24">
</span><span id="__span-26-25">    public static void closeConnection() throws SQLException {
</span><span id="__span-26-26">
</span><span id="__span-26-27">        Connection conn = connHolder.get();
</span><span id="__span-26-28">
</span><span id="__span-26-29">        if (conn != null) {
</span><span id="__span-26-30">
</span><span id="__span-26-31">            conn.close();
</span><span id="__span-26-32">
</span><span id="__span-26-33">            connHolder.remove(); // 关键的清理操作
</span><span id="__span-26-34">
</span><span id="__span-26-35">        }
</span><span id="__span-26-36">
</span><span id="__span-26-37">    }
</span><span id="__span-26-38">
</span><span id="__span-26-39">}
</span></code></pre></div></td></tr></table></div>
<p>这个示例展示了如何使用 ThreadLocal 管理数据库连接：</p>
<ol>
<li>
<p>每个线程首次调用 getConnection () 时创建连接</p>
</li>
<li>
<p>后续调用直接使用保存在 ThreadLocal 中的连接</p>
</li>
<li>
<p>连接使用完毕后调用 closeConnection () 关闭连接并清理 ThreadLocal</p>
</li>
</ol>
<p><strong>事务管理中的应用</strong>：</p>
<p>在 Spring 等框架中，ThreadLocal 被广泛用于事务管理。Spring 的事务管理通过 ThreadLocal 存储数据库连接，保证同一个事务中使用同一个数据库连接<a href="https://blog.51cto.com/u_16237826/13669223">(65)</a>。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-27-1">public class TransactionManager {
</span><span id="__span-27-2">
</span><span id="__span-27-3">    private static final ThreadLocal\&lt;Connection&gt; txHolder = new ThreadLocal&lt;&gt;();
</span><span id="__span-27-4">
</span><span id="__span-27-5">
</span><span id="__span-27-6">
</span><span id="__span-27-7">    public static void beginTransaction() throws SQLException {
</span><span id="__span-27-8">
</span><span id="__span-27-9">        Connection conn = getConnection();
</span><span id="__span-27-10">
</span><span id="__span-27-11">        txHolder.set(conn);
</span><span id="__span-27-12">
</span><span id="__span-27-13">        conn.setAutoCommit(false);
</span><span id="__span-27-14">
</span><span id="__span-27-15">    }
</span><span id="__span-27-16">
</span><span id="__span-27-17">
</span><span id="__span-27-18">
</span><span id="__span-27-19">    public static void commitTransaction() throws SQLException {
</span><span id="__span-27-20">
</span><span id="__span-27-21">        Connection conn = txHolder.get();
</span><span id="__span-27-22">
</span><span id="__span-27-23">        if (conn != null) {
</span><span id="__span-27-24">
</span><span id="__span-27-25">            conn.commit();
</span><span id="__span-27-26">
</span><span id="__span-27-27">            conn.setAutoCommit(true);
</span><span id="__span-27-28">
</span><span id="__span-27-29">            txHolder.remove();
</span><span id="__span-27-30">
</span><span id="__span-27-31">        }
</span><span id="__span-27-32">
</span><span id="__span-27-33">    }
</span><span id="__span-27-34">
</span><span id="__span-27-35">
</span><span id="__span-27-36">
</span><span id="__span-27-37">    public static void rollbackTransaction() throws SQLException {
</span><span id="__span-27-38">
</span><span id="__span-27-39">        Connection conn = txHolder.get();
</span><span id="__span-27-40">
</span><span id="__span-27-41">        if (conn != null) {
</span><span id="__span-27-42">
</span><span id="__span-27-43">            conn.rollback();
</span><span id="__span-27-44">
</span><span id="__span-27-45">            conn.setAutoCommit(true);
</span><span id="__span-27-46">
</span><span id="__span-27-47">            txHolder.remove();
</span><span id="__span-27-48">
</span><span id="__span-27-49">        }
</span><span id="__span-27-50">
</span><span id="__span-27-51">    }
</span><span id="__span-27-52">
</span><span id="__span-27-53">}
</span></code></pre></div></td></tr></table></div>
<h3 id="42">4.2 用户会话和上下文管理<a class="headerlink" href="#42" title="Permanent link">&para;</a></h3>
<p>在 Web 应用和分布式系统中，用户会话和上下文管理是 ThreadLocal 的另一个重要应用场景。</p>
<p><strong>Web 应用中的用户会话管理</strong>：</p>
<p>在 Web 框架中，ThreadLocal 常用于存储当前请求的用户上下文，如用户 ID、权限信息、语言环境等。每个 HTTP 请求由独立的线程处理，通过 ThreadLocal 可以轻松实现会话数据的线程隔离。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-28-1">public class SessionContext {
</span><span id="__span-28-2">
</span><span id="__span-28-3">    private static final ThreadLocal\&lt;String&gt; userIdHolder = new ThreadLocal&lt;&gt;();
</span><span id="__span-28-4">
</span><span id="__span-28-5">    private static final ThreadLocal\&lt;String&gt; languageHolder = new ThreadLocal&lt;&gt;();
</span><span id="__span-28-6">
</span><span id="__span-28-7">
</span><span id="__span-28-8">
</span><span id="__span-28-9">    public static void setUserId(String userId) {
</span><span id="__span-28-10">
</span><span id="__span-28-11">        userIdHolder.set(userId);
</span><span id="__span-28-12">
</span><span id="__span-28-13">    }
</span><span id="__span-28-14">
</span><span id="__span-28-15">
</span><span id="__span-28-16">
</span><span id="__span-28-17">    public static String getUserId() {
</span><span id="__span-28-18">
</span><span id="__span-28-19">        return userIdHolder.get();
</span><span id="__span-28-20">
</span><span id="__span-28-21">    }
</span><span id="__span-28-22">
</span><span id="__span-28-23">
</span><span id="__span-28-24">
</span><span id="__span-28-25">    public static void setLanguage(String language) {
</span><span id="__span-28-26">
</span><span id="__span-28-27">        languageHolder.set(language);
</span><span id="__span-28-28">
</span><span id="__span-28-29">    }
</span><span id="__span-28-30">
</span><span id="__span-28-31">
</span><span id="__span-28-32">
</span><span id="__span-28-33">    public static String getLanguage() {
</span><span id="__span-28-34">
</span><span id="__span-28-35">        return languageHolder.get();
</span><span id="__span-28-36">
</span><span id="__span-28-37">    }
</span><span id="__span-28-38">
</span><span id="__span-28-39">
</span><span id="__span-28-40">
</span><span id="__span-28-41">    public static void clear() {
</span><span id="__span-28-42">
</span><span id="__span-28-43">        userIdHolder.remove();
</span><span id="__span-28-44">
</span><span id="__span-28-45">        languageHolder.remove();
</span><span id="__span-28-46">
</span><span id="__span-28-47">    }
</span><span id="__span-28-48">
</span><span id="__span-28-49">}
</span></code></pre></div></td></tr></table></div>
<p>在 Servlet 过滤器或 Spring 拦截器中，可以在请求开始时设置用户信息，请求结束时清理：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-29-1">public class SessionFilter implements Filter {
</span><span id="__span-29-2">
</span><span id="__span-29-3">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
</span><span id="__span-29-4">
</span><span id="__span-29-5">        try {
</span><span id="__span-29-6">
</span><span id="__span-29-7">            // 从请求中获取用户ID和语言信息
</span><span id="__span-29-8">
</span><span id="__span-29-9">            String userId = request.getHeader(&quot;X-User-Id&quot;);
</span><span id="__span-29-10">
</span><span id="__span-29-11">            String language = request.getHeader(&quot;X-Language&quot;);
</span><span id="__span-29-12">
</span><span id="__span-29-13">
</span><span id="__span-29-14">
</span><span id="__span-29-15">            SessionContext.setUserId(userId);
</span><span id="__span-29-16">
</span><span id="__span-29-17">            SessionContext.setLanguage(language);
</span><span id="__span-29-18">
</span><span id="__span-29-19">
</span><span id="__span-29-20">
</span><span id="__span-29-21">            chain.doFilter(request, response);
</span><span id="__span-29-22">
</span><span id="__span-29-23">        } finally {
</span><span id="__span-29-24">
</span><span id="__span-29-25">            SessionContext.clear(); // 确保清理
</span><span id="__span-29-26">
</span><span id="__span-29-27">        }
</span><span id="__span-29-28">
</span><span id="__span-29-29">    }
</span><span id="__span-29-30">
</span><span id="__span-29-31">}
</span></code></pre></div></td></tr></table></div>
<p><strong>分布式系统中的请求上下文</strong>：</p>
<p>在微服务架构中，一个请求通常会穿越多个服务或线程。ThreadLocal 常用于存储请求上下文信息，如用户认证信息、追踪日志 ID 等。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-30-1">public class RequestContext {
</span><span id="__span-30-2">
</span><span id="__span-30-3">    private static final ThreadLocal\&lt;String&gt; traceIdHolder = new ThreadLocal&lt;&gt;();
</span><span id="__span-30-4">
</span><span id="__span-30-5">    private static final ThreadLocal\&lt;Map\&lt;String, String&gt;&gt; headersHolder = new ThreadLocal&lt;&gt;();
</span><span id="__span-30-6">
</span><span id="__span-30-7">
</span><span id="__span-30-8">
</span><span id="__span-30-9">    public static void setTraceId(String traceId) {
</span><span id="__span-30-10">
</span><span id="__span-30-11">        traceIdHolder.set(traceId);
</span><span id="__span-30-12">
</span><span id="__span-30-13">    }
</span><span id="__span-30-14">
</span><span id="__span-30-15">
</span><span id="__span-30-16">
</span><span id="__span-30-17">    public static String getTraceId() {
</span><span id="__span-30-18">
</span><span id="__span-30-19">        return traceIdHolder.get();
</span><span id="__span-30-20">
</span><span id="__span-30-21">    }
</span><span id="__span-30-22">
</span><span id="__span-30-23">
</span><span id="__span-30-24">
</span><span id="__span-30-25">    public static void setHeaders(Map\&lt;String, String&gt; headers) {
</span><span id="__span-30-26">
</span><span id="__span-30-27">        headersHolder.set(new HashMap&lt;&gt;(headers));
</span><span id="__span-30-28">
</span><span id="__span-30-29">    }
</span><span id="__span-30-30">
</span><span id="__span-30-31">
</span><span id="__span-30-32">
</span><span id="__span-30-33">    public static Map\&lt;String, String&gt; getHeaders() {
</span><span id="__span-30-34">
</span><span id="__span-30-35">        return headersHolder.get();
</span><span id="__span-30-36">
</span><span id="__span-30-37">    }
</span><span id="__span-30-38">
</span><span id="__span-30-39">}
</span></code></pre></div></td></tr></table></div>
<h3 id="43">4.3 日志追踪和链路监控<a class="headerlink" href="#43" title="Permanent link">&para;</a></h3>
<p>在分布式系统中，日志追踪是定位问题的关键。ThreadLocal 在日志追踪中扮演着重要角色。</p>
<p><strong>生成和传递追踪 ID</strong>：</p>
<p>在分布式调用链中，为每个请求生成唯一的追踪 ID，在日志中统一打印追踪 ID，便于调试和追踪问题。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-31-1">public class TraceIdGenerator {
</span><span id="__span-31-2">
</span><span id="__span-31-3">    private static final ThreadLocal\&lt;String&gt; traceIdHolder = new ThreadLocal&lt;&gt;();
</span><span id="__span-31-4">
</span><span id="__span-31-5">
</span><span id="__span-31-6">
</span><span id="__span-31-7">    public static String generateTraceId() {
</span><span id="__span-31-8">
</span><span id="__span-31-9">        String traceId = UUID.randomUUID().toString();
</span><span id="__span-31-10">
</span><span id="__span-31-11">        traceIdHolder.set(traceId);
</span><span id="__span-31-12">
</span><span id="__span-31-13">        return traceId;
</span><span id="__span-31-14">
</span><span id="__span-31-15">    }
</span><span id="__span-31-16">
</span><span id="__span-31-17">
</span><span id="__span-31-18">
</span><span id="__span-31-19">    public static String getTraceId() {
</span><span id="__span-31-20">
</span><span id="__span-31-21">        String traceId = traceIdHolder.get();
</span><span id="__span-31-22">
</span><span id="__span-31-23">        if (traceId == null) {
</span><span id="__span-31-24">
</span><span id="__span-31-25">            traceId = generateTraceId();
</span><span id="__span-31-26">
</span><span id="__span-31-27">        }
</span><span id="__span-31-28">
</span><span id="__span-31-29">        return traceId;
</span><span id="__span-31-30">
</span><span id="__span-31-31">    }
</span><span id="__span-31-32">
</span><span id="__span-31-33">}
</span></code></pre></div></td></tr></table></div>
<p><strong>日志记录器的集成</strong>：</p>
<p>在日志记录中，可以存储一些线程相关的上下文信息，例如线程 ID、请求 ID 等，方便排查问题<a href="https://m.php.cn/faq/1534445.html">(66)</a>。通过为每个线程设置独立的日志上下文，日志信息更加清晰，便于开发者追踪每个线程的执行过程，快速定位问题<a href="https://moke.laixiai.com/post/17e85327d2924dfe99c27408904dd0ce">(67)</a>。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-32-1">public class LogContext {
</span><span id="__span-32-2">
</span><span id="__span-32-3">    private static final ThreadLocal\&lt;String&gt; traceId = new ThreadLocal&lt;&gt;();
</span><span id="__span-32-4">
</span><span id="__span-32-5">    private static final ThreadLocal\&lt;String&gt; userId = new ThreadLocal&lt;&gt;();
</span><span id="__span-32-6">
</span><span id="__span-32-7">
</span><span id="__span-32-8">
</span><span id="__span-32-9">    public static void setTraceId(String traceId) {
</span><span id="__span-32-10">
</span><span id="__span-32-11">        LogContext.traceId.set(traceId);
</span><span id="__span-32-12">
</span><span id="__span-32-13">    }
</span><span id="__span-32-14">
</span><span id="__span-32-15">
</span><span id="__span-32-16">
</span><span id="__span-32-17">    public static void setUserId(String userId) {
</span><span id="__span-32-18">
</span><span id="__span-32-19">        LogContext.userId.set(userId);
</span><span id="__span-32-20">
</span><span id="__span-32-21">    }
</span><span id="__span-32-22">
</span><span id="__span-32-23">
</span><span id="__span-32-24">
</span><span id="__span-32-25">    public static String getLogMessagePrefix() {
</span><span id="__span-32-26">
</span><span id="__span-32-27">        return String.format(
</span><span id="__span-32-28">
</span><span id="__span-32-29">            &quot;\[traceId=%s, userId=%s, thread=%s]&quot;,
</span><span id="__span-32-30">
</span><span id="__span-32-31">            traceId.get() != null ? traceId.get() : &quot;N/A&quot;,
</span><span id="__span-32-32">
</span><span id="__span-32-33">            userId.get() != null ? userId.get() : &quot;N/A&quot;,
</span><span id="__span-32-34">
</span><span id="__span-32-35">            Thread.currentThread().getName()
</span><span id="__span-32-36">
</span><span id="__span-32-37">        );
</span><span id="__span-32-38">
</span><span id="__span-32-39">    }
</span><span id="__span-32-40">
</span><span id="__span-32-41">}
</span></code></pre></div></td></tr></table></div>
<p>使用示例：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-33-1">public class SomeService {
</span><span id="__span-33-2">
</span><span id="__span-33-3">    public void someMethod() {
</span><span id="__span-33-4">
</span><span id="__span-33-5">        String prefix = LogContext.getLogMessagePrefix();
</span><span id="__span-33-6">
</span><span id="__span-33-7">        System.out.println(prefix + &quot; 进入someMethod方法&quot;);
</span><span id="__span-33-8">
</span><span id="__span-33-9">
</span><span id="__span-33-10">
</span><span id="__span-33-11">        // 业务逻辑...
</span><span id="__span-33-12">
</span><span id="__span-33-13">
</span><span id="__span-33-14">
</span><span id="__span-33-15">        System.out.println(prefix + &quot; 退出someMethod方法&quot;);
</span><span id="__span-33-16">
</span><span id="__span-33-17">    }
</span><span id="__span-33-18">
</span><span id="__span-33-19">}
</span></code></pre></div></td></tr></table></div>
<h3 id="44">4.4 线程安全的工具类管理<a class="headerlink" href="#44" title="Permanent link">&para;</a></h3>
<p>许多工具类不是线程安全的，使用 ThreadLocal 可以让这些工具类在多线程环境下安全使用。</p>
<p><strong>SimpleDateFormat 的线程安全问题</strong>：</p>
<p>SimpleDateFormat 是典型的非线程安全类。当线程池开启，提交大量任务时，每个线程都创建属于自己的 SimpleDateFormat 开销会很大，而且占用内存<a href="https://blog.csdn.net/ke1ying/article/details/116796733">(55)</a>。使用 synchronized 加锁可以解决线程安全问题，但会发生阻塞，影响效率。</p>
<p><strong>使用 ThreadLocal 的解决方案</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-34-1">public class DateFormatUtil {
</span><span id="__span-34-2">
</span><span id="__span-34-3">    private static final ThreadLocal\&lt;SimpleDateFormat&gt; dateFormatHolder = 
</span><span id="__span-34-4">
</span><span id="__span-34-5">        ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));
</span><span id="__span-34-6">
</span><span id="__span-34-7">
</span><span id="__span-34-8">
</span><span id="__span-34-9">    public static String formatDate(Date date) {
</span><span id="__span-34-10">
</span><span id="__span-34-11">        return dateFormatHolder.get().format(date);
</span><span id="__span-34-12">
</span><span id="__span-34-13">    }
</span><span id="__span-34-14">
</span><span id="__span-34-15">
</span><span id="__span-34-16">
</span><span id="__span-34-17">    public static Date parseDate(String dateStr) throws ParseException {
</span><span id="__span-34-18">
</span><span id="__span-34-19">        return dateFormatHolder.get().parse(dateStr);
</span><span id="__span-34-20">
</span><span id="__span-34-21">    }
</span><span id="__span-34-22">
</span><span id="__span-34-23">}
</span></code></pre></div></td></tr></table></div>
<p>这个方案的优势：</p>
<ol>
<li>
<p>每个线程拥有独立的 SimpleDateFormat 实例</p>
</li>
<li>
<p>避免了创建多个实例的内存开销</p>
</li>
<li>
<p>避免了 synchronized 的性能开销</p>
</li>
<li>
<p>保证了线程安全</p>
</li>
</ol>
<p><strong>其他非线程安全类的应用</strong>：</p>
<p>除了 SimpleDateFormat，类似的非线程安全类还包括：</p>
<ul>
<li>
<p>Random 类（线程安全版本为 ThreadLocalRandom）</p>
</li>
<li>
<p>各种 Parser 类（如 XMLParser、JSONParser）</p>
</li>
<li>
<p>一些第三方工具类</p>
</li>
</ul>
<h3 id="45">4.5 避免方法参数的层层传递<a class="headerlink" href="#45" title="Permanent link">&para;</a></h3>
<p>在复杂的调用链中，经常需要传递一些上下文参数，使用 ThreadLocal 可以避免方法参数的层层传递。</p>
<p><strong>传统的参数传递方式</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-35-1">public class TraditionalApproach {
</span><span id="__span-35-2">
</span><span id="__span-35-3">    public void methodA(String param1, String context) {
</span><span id="__span-35-4">
</span><span id="__span-35-5">        methodB(param1, context);
</span><span id="__span-35-6">
</span><span id="__span-35-7">    }
</span><span id="__span-35-8">
</span><span id="__span-35-9">
</span><span id="__span-35-10">
</span><span id="__span-35-11">    public void methodB(String param2, String context) {
</span><span id="__span-35-12">
</span><span id="__span-35-13">        methodC(param2, context);
</span><span id="__span-35-14">
</span><span id="__span-35-15">    }
</span><span id="__span-35-16">
</span><span id="__span-35-17">
</span><span id="__span-35-18">
</span><span id="__span-35-19">    public void methodC(String param3, String context) {
</span><span id="__span-35-20">
</span><span id="__span-35-21">        // 使用context参数
</span><span id="__span-35-22">
</span><span id="__span-35-23">        System.out.println(&quot;context: &quot; + context);
</span><span id="__span-35-24">
</span><span id="__span-35-25">    }
</span><span id="__span-35-26">
</span><span id="__span-35-27">}
</span></code></pre></div></td></tr></table></div>
<p>这种方式的问题：</p>
<ol>
<li>
<p>方法签名变得复杂</p>
</li>
<li>
<p>即使中间方法不需要 context 参数，也必须传递</p>
</li>
<li>
<p>维护困难，容易出错</p>
</li>
</ol>
<p><strong>使用 ThreadLocal 的改进方案</strong>：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-36-1">public class ThreadLocalApproach {
</span><span id="__span-36-2">
</span><span id="__span-36-3">    private static final ThreadLocal\&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();
</span><span id="__span-36-4">
</span><span id="__span-36-5">
</span><span id="__span-36-6">
</span><span id="__span-36-7">    public void methodA(String param1) {
</span><span id="__span-36-8">
</span><span id="__span-36-9">        contextHolder.set(&quot;上下文数据&quot;);
</span><span id="__span-36-10">
</span><span id="__span-36-11">        methodB(param1);
</span><span id="__span-36-12">
</span><span id="__span-36-13">    }
</span><span id="__span-36-14">
</span><span id="__span-36-15">
</span><span id="__span-36-16">
</span><span id="__span-36-17">    public void methodB(String param2) {
</span><span id="__span-36-18">
</span><span id="__span-36-19">        methodC(param2);
</span><span id="__span-36-20">
</span><span id="__span-36-21">    }
</span><span id="__span-36-22">
</span><span id="__span-36-23">
</span><span id="__span-36-24">
</span><span id="__span-36-25">    public void methodC(String param3) {
</span><span id="__span-36-26">
</span><span id="__span-36-27">        String context = contextHolder.get();
</span><span id="__span-36-28">
</span><span id="__span-36-29">        System.out.println(&quot;context: &quot; + context);
</span><span id="__span-36-30">
</span><span id="__span-36-31">    }
</span><span id="__span-36-32">
</span><span id="__span-36-33">}
</span></code></pre></div></td></tr></table></div>
<p>优势：</p>
<ol>
<li>
<p>方法签名简洁</p>
</li>
<li>
<p>不需要在方法间传递上下文参数</p>
</li>
<li>
<p>代码更清晰，维护更容易</p>
</li>
</ol>
<p>但需要注意的是，过度使用 ThreadLocal 会导致隐式依赖，降低代码的可读性和可维护性。因此，应该在合适的场景下使用，并明确 ThreadLocal 的使用边界。</p>
<h2 id="threadlocal_5">五、ThreadLocal 使用的最佳实践<a class="headerlink" href="#threadlocal_5" title="Permanent link">&para;</a></h2>
<h3 id="51">5.1 内存管理的最佳实践<a class="headerlink" href="#51" title="Permanent link">&para;</a></h3>
<p>内存管理是使用 ThreadLocal 时最重要的最佳实践，直接关系到应用的稳定性和性能。</p>
<p><strong>始终在 finally 块中调用 remove () 方法</strong>：</p>
<p>这是最核心的最佳实践。使用 try-finally 块确保 ThreadLocal 被清理，就像使用完资源后必须关闭一样：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-37-1">try {
</span><span id="__span-37-2">
</span><span id="__span-37-3">    threadLocal.set(value);
</span><span id="__span-37-4">
</span><span id="__span-37-5">    // 业务逻辑...
</span><span id="__span-37-6">
</span><span id="__span-37-7">} finally {
</span><span id="__span-37-8">
</span><span id="__span-37-9">    threadLocal.remove(); // 必须调用
</span><span id="__span-37-10">
</span><span id="__span-37-11">}
</span></code></pre></div></td></tr></table></div>
<p>为什么必须这样做？原因包括：</p>
<ol>
<li>
<p>防止内存泄漏：避免 ThreadLocalMap 中积累无效的 Entry</p>
</li>
<li>
<p>防止数据污染：在线程池环境下，避免下一个任务获取到上一个任务的数据</p>
</li>
<li>
<p>释放内存：及时释放不再使用的对象引用</p>
</li>
</ol>
<p><strong>使用 static final 修饰 ThreadLocal 实例</strong>：</p>
<p>使用 static final 修饰 ThreadLocal 变量有多重好处：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-38-1">private static final ThreadLocal\&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();
</span></code></pre></div></td></tr></table></div>
<p>优势：</p>
<ol>
<li>
<p><strong>避免重复创建实例</strong>：节省内存，提高性能</p>
</li>
<li>
<p><strong>统一管理生命周期</strong>：便于查找和清理</p>
</li>
<li>
<p><strong>线程安全</strong>：static final 确保只有一个实例，避免并发问题</p>
</li>
</ol>
<p><strong>避免存储大对象</strong>：</p>
<p>不要在 ThreadLocal 中存储大对象，如：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-39-1">// 错误示范！
</span><span id="__span-39-2">
</span><span id="__span-39-3">ThreadLocal\&lt;byte\[]&gt; bigData = new ThreadLocal&lt;&gt;();
</span><span id="__span-39-4">
</span><span id="__span-39-5">bigData.set(new byte\[1024 \* 1024]); // 1MB的数据
</span></code></pre></div></td></tr></table></div>
<p>原因：</p>
<ol>
<li>
<p>线程越多内存占用越大</p>
</li>
<li>
<p>容易导致 OOM（OutOfMemoryError）</p>
</li>
<li>
<p>即使调用了 remove ()，大对象的回收也需要时间</p>
</li>
</ol>
<p><strong>及时清理策略</strong>：</p>
<ol>
<li>
<p><strong>使用后立即清理</strong>：在代码逻辑结束时调用 threadLocal.remove ()<a href="https://www.cnblogs.com/jock766/p/18750823">(77)</a></p>
</li>
<li>
<p><strong>使用弱引用包装</strong>：虽然 ThreadLocalMap 已经使用了弱引用，但在某些情况下，可能还需要手动使用弱引用来包装存储在 ThreadLocal 中的对象，以进一步降低内存泄漏的风险<a href="https://www.cnblogs.com/cabbagehp/p/18801641">(78)</a></p>
</li>
<li>
<p><strong>定期检查</strong>：在长时间运行的应用中，考虑定期检查和清理 ThreadLocal 变量</p>
</li>
</ol>
<h3 id="52">5.2 线程池环境下的特殊处理<a class="headerlink" href="#52" title="Permanent link">&para;</a></h3>
<p>线程池环境下使用 ThreadLocal 需要特别小心，因为线程会被重用，处理不当会导致严重问题。</p>
<p><strong>线程池中的数据污染问题</strong>：</p>
<p>线程池中的线程会被重用，如果不清理，可能导致：</p>
<ol>
<li>
<p>数据泄露：下一个任务获取到上一个任务的敏感数据</p>
</li>
<li>
<p>逻辑错误：基于错误的数据执行逻辑</p>
</li>
<li>
<p>性能问题：内存占用不断增长</p>
</li>
</ol>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>强制清理模式</strong>：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-40-1">ExecutorService executor = Executors.newFixedThreadPool(2);
</span><span id="__span-40-2">
</span><span id="__span-40-3">executor.submit(() -&gt; {
</span><span id="__span-40-4">
</span><span id="__span-40-5">    try {
</span><span id="__span-40-6">
</span><span id="__span-40-7">        threadLocal.set(value);
</span><span id="__span-40-8">
</span><span id="__span-40-9">        // 任务逻辑
</span><span id="__span-40-10">
</span><span id="__span-40-11">    } finally {
</span><span id="__span-40-12">
</span><span id="__span-40-13">        threadLocal.remove(); // 必须清理
</span><span id="__span-40-14">
</span><span id="__span-40-15">    }
</span><span id="__span-40-16">
</span><span id="__span-40-17">});
</span></code></pre></div></td></tr></table></div>
<ol>
<li><strong>任务开始前重置</strong>：</li>
</ol>
<p>在线程池场景下，由于线程会被重复使用，因此每次任务开始执行前最好都通过 set () 方法设置正确的 ThreadLocal 变量值，确保不会因为线程复用而出现数据混乱<a href="https://www.cnblogs.com/use-D/p/18224878">(71)</a>。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-41-1">executor.submit(() -&gt; {
</span><span id="__span-41-2">
</span><span id="__span-41-3">    // 任务开始时重置
</span><span id="__span-41-4">
</span><span id="__span-41-5">    threadLocal.set(null);
</span><span id="__span-41-6">
</span><span id="__span-41-7">
</span><span id="__span-41-8">
</span><span id="__span-41-9">    try {
</span><span id="__span-41-10">
</span><span id="__span-41-11">        threadLocal.set(newValue);
</span><span id="__span-41-12">
</span><span id="__span-41-13">        // 任务逻辑
</span><span id="__span-41-14">
</span><span id="__span-41-15">    } finally {
</span><span id="__span-41-16">
</span><span id="__span-41-17">        threadLocal.remove();
</span><span id="__span-41-18">
</span><span id="__span-41-19">    }
</span><span id="__span-41-20">
</span><span id="__span-41-21">});
</span></code></pre></div></td></tr></table></div>
<ol>
<li><strong>使用专门的清理线程</strong>：</li>
</ol>
<p>对于长期运行的线程池，可以考虑创建一个专门的清理线程，定期清理闲置线程的 ThreadLocal 数据。</p>
<h3 id="53">5.3 性能优化策略<a class="headerlink" href="#53" title="Permanent link">&para;</a></h3>
<p>虽然 ThreadLocal 本身已经具有很好的性能，但在某些场景下仍可以进一步优化。</p>
<p><strong>预初始化策略</strong>：</p>
<p>对于频繁使用的 ThreadLocal，可以使用 withInitial () 方法进行预初始化，避免首次调用 get () 时的初始化开销：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-42-1">private static final ThreadLocal\&lt;MyClass&gt; threadLocal = 
</span><span id="__span-42-2">
</span><span id="__span-42-3">    ThreadLocal.withInitial(MyClass::new);
</span></code></pre></div></td></tr></table></div>
<p><strong>对象池结合使用</strong>：</p>
<p>对于创建成本较高的对象，可以结合对象池使用 ThreadLocal，进一步提高性能：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-43-1">public class ObjectPool {
</span><span id="__span-43-2">
</span><span id="__span-43-3">    private static final ThreadLocal\&lt;Stack\&lt;MyObject&gt;&gt; poolHolder = 
</span><span id="__span-43-4">
</span><span id="__span-43-5">        ThreadLocal.withInitial(Stack::new);
</span><span id="__span-43-6">
</span><span id="__span-43-7">
</span><span id="__span-43-8">
</span><span id="__span-43-9">    public static MyObject borrowObject() {
</span><span id="__span-43-10">
</span><span id="__span-43-11">        Stack\&lt;MyObject&gt; stack = poolHolder.get();
</span><span id="__span-43-12">
</span><span id="__span-43-13">        return stack.isEmpty() ? new MyObject() : stack.pop();
</span><span id="__span-43-14">
</span><span id="__span-43-15">    }
</span><span id="__span-43-16">
</span><span id="__span-43-17">
</span><span id="__span-43-18">
</span><span id="__span-43-19">    public static void returnObject(MyObject object) {
</span><span id="__span-43-20">
</span><span id="__span-43-21">        poolHolder.get().push(object);
</span><span id="__span-43-22">
</span><span id="__span-43-23">    }
</span><span id="__span-43-24">
</span><span id="__span-43-25">}
</span></code></pre></div></td></tr></table></div>
<p><strong>批量操作优化</strong>：</p>
<p>如果需要在一个线程中多次使用 ThreadLocal，可以考虑批量操作，减少方法调用开销：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-44-1">// 不推荐：多次set操作
</span><span id="__span-44-2">
</span><span id="__span-44-3">threadLocal.set(a);
</span><span id="__span-44-4">
</span><span id="__span-44-5">doSomething();
</span><span id="__span-44-6">
</span><span id="__span-44-7">threadLocal.set(b);
</span><span id="__span-44-8">
</span><span id="__span-44-9">doSomethingElse();
</span><span id="__span-44-10">
</span><span id="__span-44-11">// 推荐：批量处理
</span><span id="__span-44-12">
</span><span id="__span-44-13">List\&lt;Data&gt; dataList = Arrays.asList(a, b, c);
</span><span id="__span-44-14">
</span><span id="__span-44-15">for (Data data : dataList) {
</span><span id="__span-44-16">
</span><span id="__span-44-17">    process(data);
</span><span id="__span-44-18">
</span><span id="__span-44-19">}
</span></code></pre></div></td></tr></table></div>
<h3 id="54">5.4 代码规范和设计原则<a class="headerlink" href="#54" title="Permanent link">&para;</a></h3>
<p>遵循良好的代码规范和设计原则，可以使 ThreadLocal 的使用更加优雅和安全。</p>
<p><strong>明确使用边界</strong>：</p>
<p>过度使用 ThreadLocal 会导致代码中隐藏依赖，降低可读性和可维护性。应该：</p>
<ol>
<li>
<p>在项目设计中明确 ThreadLocal 的使用边界</p>
</li>
<li>
<p>通过工具类封装，避免直接操作 ThreadLocal</p>
</li>
<li>
<p>编写清晰的文档说明</p>
</li>
</ol>
<p><strong>使用工具类封装</strong>：</p>
<p>创建专门的工具类来封装 ThreadLocal 的操作，提高代码的复用性和可维护性：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-45-1">public class ThreadLocalUtil\&lt;T&gt; {
</span><span id="__span-45-2">
</span><span id="__span-45-3">    private final ThreadLocal\&lt;T&gt; threadLocal;
</span><span id="__span-45-4">
</span><span id="__span-45-5">
</span><span id="__span-45-6">
</span><span id="__span-45-7">    public ThreadLocalUtil(Supplier\&lt;T&gt; supplier) {
</span><span id="__span-45-8">
</span><span id="__span-45-9">        this.threadLocal = ThreadLocal.withInitial(supplier);
</span><span id="__span-45-10">
</span><span id="__span-45-11">    }
</span><span id="__span-45-12">
</span><span id="__span-45-13">
</span><span id="__span-45-14">
</span><span id="__span-45-15">    public T get() {
</span><span id="__span-45-16">
</span><span id="__span-45-17">        return threadLocal.get();
</span><span id="__span-45-18">
</span><span id="__span-45-19">    }
</span><span id="__span-45-20">
</span><span id="__span-45-21">
</span><span id="__span-45-22">
</span><span id="__span-45-23">    public void set(T value) {
</span><span id="__span-45-24">
</span><span id="__span-45-25">        threadLocal.set(value);
</span><span id="__span-45-26">
</span><span id="__span-45-27">    }
</span><span id="__span-45-28">
</span><span id="__span-45-29">
</span><span id="__span-45-30">
</span><span id="__span-45-31">    public void remove() {
</span><span id="__span-45-32">
</span><span id="__span-45-33">        threadLocal.remove();
</span><span id="__span-45-34">
</span><span id="__span-45-35">    }
</span><span id="__span-45-36">
</span><span id="__span-45-37">
</span><span id="__span-45-38">
</span><span id="__span-45-39">    public void clear() {
</span><span id="__span-45-40">
</span><span id="__span-45-41">        threadLocal.remove();
</span><span id="__span-45-42">
</span><span id="__span-45-43">    }
</span><span id="__span-45-44">
</span><span id="__span-45-45">}
</span></code></pre></div></td></tr></table></div>
<p><strong>异常处理</strong>：</p>
<p>在使用 ThreadLocal 的过程中，可能会遇到 NullPointerException 等异常，要确保代码能够妥善处理这些异常情况：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-46-1">public class SafeThreadLocalUsage {
</span><span id="__span-46-2">
</span><span id="__span-46-3">    private static final ThreadLocal\&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();
</span><span id="__span-46-4">
</span><span id="__span-46-5">
</span><span id="__span-46-6">
</span><span id="__span-46-7">    public static void safeGet() {
</span><span id="__span-46-8">
</span><span id="__span-46-9">        String value = threadLocal.get();
</span><span id="__span-46-10">
</span><span id="__span-46-11">        if (value == null) {
</span><span id="__span-46-12">
</span><span id="__span-46-13">            // 处理null值的情况
</span><span id="__span-46-14">
</span><span id="__span-46-15">            return;
</span><span id="__span-46-16">
</span><span id="__span-46-17">        }
</span><span id="__span-46-18">
</span><span id="__span-46-19">        // 其他处理逻辑
</span><span id="__span-46-20">
</span><span id="__span-46-21">    }
</span><span id="__span-46-22">
</span><span id="__span-46-23">}
</span></code></pre></div></td></tr></table></div>
<h3 id="55">5.5 常见错误和陷阱<a class="headerlink" href="#55" title="Permanent link">&para;</a></h3>
<p>了解常见错误和陷阱，可以帮助开发者避免踩坑。</p>
<p><strong>错误 1：忘记调用 remove ()</strong></p>
<p>这是最常见的错误，后果包括内存泄漏和数据污染。</p>
<p><strong>错误 2：在父子线程间误用 ThreadLocal</strong></p>
<p>ThreadLocal 的数据不能在父子线程间共享，误用会导致逻辑错误。如果需要父子线程间传递数据，应该使用 InheritableThreadLocal。</p>
<p><strong>错误 3：存储可变对象</strong></p>
<p>如果在 ThreadLocal 中存储了可变对象，要注意：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-47-1">InheritableThreadLocal\&lt;User&gt; userThreadLocal = new InheritableThreadLocal&lt;&gt;();
</span><span id="__span-47-2">
</span><span id="__span-47-3">userThreadLocal.set(new User(&quot;parent&quot;));
</span><span id="__span-47-4">
</span><span id="__span-47-5">new Thread(() -&gt; {
</span><span id="__span-47-6">
</span><span id="__span-47-7">    User user = userThreadLocal.get();
</span><span id="__span-47-8">
</span><span id="__span-47-9">    user.setName(&quot;child&quot;); // 会影响父线程的数据
</span><span id="__span-47-10">
</span><span id="__span-47-11">}).start();
</span></code></pre></div></td></tr></table></div>
<p>解决方案：使用深拷贝或不可变对象。</p>
<p><strong>错误 4：在线程池中使用静态变量</strong></p>
<p>不要在线程池中使用静态的非 ThreadLocal 变量，否则会导致线程安全问题。</p>
<p><strong>错误 5：过度使用 ThreadLocal</strong></p>
<p>虽然 ThreadLocal 很强大，但不应该滥用。在以下情况不应该使用 ThreadLocal：</p>
<ol>
<li>
<p>需要跨线程共享的数据</p>
</li>
<li>
<p>数据量非常大的情况</p>
</li>
<li>
<p>需要持久化存储的数据</p>
</li>
<li>
<p>简单的方法参数传递场景</p>
</li>
</ol>
<p><strong>错误 6：在 J2EE 容器中使用 ThreadLocal</strong></p>
<p>在某些 J2EE 容器（如 OC4J、OCS）中，不应该使用 ThreadLocal，因为容器可能会重用线程，导致数据混乱<a href="https://support.oracle.com/knowledge/More%20Applications%20and%20Technologies/881757_1.html">(19)</a>。</p>
<h2 id="_1">六、总结与展望<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>通过对 ThreadLocal 的全面分析，我们可以得出以下核心结论：</p>
<p><strong>ThreadLocal 的本质</strong>是 Java 提供的线程级变量隔离机制，通过为每个线程创建独立的变量副本，实现了真正的线程安全。它采用 "空间换时间" 的策略，通过避免共享和同步，获得了优异的性能。</p>
<p><strong>核心原理</strong>基于 Thread、ThreadLocal 和 ThreadLocalMap 的协作。每个线程维护自己的 ThreadLocalMap，使用 ThreadLocal 实例作为弱引用键，存储线程本地变量。这种设计巧妙地解决了线程隔离问题，但也带来了内存管理的挑战。</p>
<p><strong>应用场景广泛</strong>，包括数据库连接管理、用户会话管理、日志追踪、线程安全工具类管理等。在这些场景中，ThreadLocal 都展现出了独特的优势。</p>
<p><strong>最佳实践的核心</strong>是始终调用 remove () 方法、使用 static final 修饰、避免存储大对象、在线程池环境下特别小心。只有遵循这些最佳实践，才能充分发挥 ThreadLocal 的优势，避免潜在的问题。</p>
<p>展望未来，随着 Java 并发编程的不断发展，ThreadLocal 的重要性将持续提升。建议开发者：</p>
<ol>
<li>
<p>深入理解 ThreadLocal 的实现原理，这是正确使用的基础</p>
</li>
<li>
<p>严格遵循最佳实践，养成良好的编码习惯</p>
</li>
<li>
<p>在实际项目中积极应用，但要避免滥用</p>
</li>
<li>
<p>关注 Java 新版本中关于 ThreadLocal 的改进和优化</p>
</li>
</ol>
<p>ThreadLocal 是 Java 并发编程中的一把 "双刃剑"，正确使用可以极大提升开发效率和程序性能，使用不当则可能带来严重的问题。希望通过本文的详细分析，能够帮助读者更好地理解和使用 ThreadLocal，在并发编程的道路上走得更远。</p>
<p>**参考资料 **</p>
<p>[1] ThreadLocal 知识详解:基本使用、原理与注意事项_threadlocal 使用-CSDN博客<a href="https://blog.csdn.net/2301_81511613/article/details/148382684"> https://blog.csdn.net/2301_81511613/article/details/148382684</a></p>
<p>[2] 深入学习Java多线程:ThreadLocal的全面解析与实践_圣逸的技术博客_51CTO博客<a href="https://blog.51cto.com/u_17035323/14112416"> https://blog.51cto.com/u_17035323/14112416</a></p>
<p>[3] ThreadLocal 详解及底层实现原理 - 好记性不如烂笔头=&gt; - 博客园<a href="https://www.cnblogs.com/xiaowangbangzhu/p/18874645"> https://www.cnblogs.com/xiaowangbangzhu/p/18874645</a></p>
<p>[4] 深入剖析Java中ThreadLocal原理_夏夜的技术博客_51CTO博客<a href="https://blog.51cto.com/xaye/13816386"> https://blog.51cto.com/xaye/13816386</a></p>
<p>[5] 实战指南:理解 ThreadLocal 原理并用于Java 多线程上下文管理 - 测试小萌新一枚 - 博客园<a href="https://www.cnblogs.com/-lhl/articles/18764184"> https://www.cnblogs.com/-lhl/articles/18764184</a></p>
<p>[6] 重学Java基础篇—ThreadLocal深度解析与最佳实践-腾讯云开发者社区-腾讯云<a href="https://cloud.tencent.com/developer/article/2506222"> https://cloud.tencent.com/developer/article/2506222</a></p>
<p>[7] ThreadLocal原理分析ThreadLocal 是 Java 中的一种线程局部存储机制，它允许每个线程拥有自己的独 - 掘金<a href="https://juejin.cn/post/7481580233646293018"> https://juejin.cn/post/7481580233646293018</a></p>
<p>[8] Java并发编程利器:深入解析ThreadLocal_off_time的技术博客_51CTO博客<a href="https://blog.51cto.com/u_15266301/13797655"> https://blog.51cto.com/u_15266301/13797655</a></p>
<p>[9] 线程隔离ThreadLocal -CSDN博客<a href="https://blog.csdn.net/NIIT0532/article/details/149348840"> https://blog.csdn.net/NIIT0532/article/details/149348840</a></p>
<p>[10] 【ThreadLocal总结】-CSDN博客<a href="https://blog.csdn.net/weixin_47068446/article/details/140966262"> https://blog.csdn.net/weixin_47068446/article/details/140966262</a></p>
<p>[11] ThreadLocal:Java多线程编程的“利器”与“陷阱”-腾讯云开发者社区-腾讯云<a href="https://cloud.tencent.com/developer/article/2517742"> https://cloud.tencent.com/developer/article/2517742</a></p>
<p>[12] ThreadLocal - 原理与应用场景详解-阿里云开发者社区<a href="https://developer.aliyun.com/article/1661553"> https://developer.aliyun.com/article/1661553</a></p>
<p>[13] ThreadLocal的理解和使用_王大师的技术博客_51CTO博客<a href="https://blog.51cto.com/wangwenfeng/12247204"> https://blog.51cto.com/wangwenfeng/12247204</a></p>
<p>[14] Class ThreadLocal<a href="https://docs.oracle.com/javame/config/cdc/ref-impl/cdc1.1.2/jsr218/java/lang/ThreadLocal.html"> https://docs.oracle.com/javame/config/cdc/ref-impl/cdc1.1.2/jsr218/java/lang/ThreadLocal.html</a></p>
<p>[15] 4.2 Thread-Local Storage<a href="http://docs.oracle.com/cd/E19205-01/819-5267/6n7c46drv/index.html"> http://docs.oracle.com/cd/E19205-01/819-5267/6n7c46drv/index.html</a></p>
<p>[16] com.tangosol.util</p>
<p>Class ThreadLocalObject<a href="http://docs.oracle.com/middleware/1213/coherence/java-reference/com/tangosol/util/ThreadLocalObject.html"> http://docs.oracle.com/middleware/1213/coherence/java-reference/com/tangosol/util/ThreadLocalObject.html</a></p>
<p>[17] Class Thread<a href="http://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Thread.html"> http://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Thread.html</a></p>
<p>[18] ThreadLocal Class in Java<a href="https://www.javaguides.net/2018/09/threadlocal-class-in-java.html?m=1\&amp;sa=U\&amp;ved=2ahUKEwjLsIeRndeCAxUulGoFHU0RDrcQFnoECAgQAg\&amp;usg=AOvVaw08f8iaLIw7yHSVqajvFaVv"> https://www.javaguides.net/2018/09/threadlocal-class-in-java.html?m=1\&amp;sa=U\&amp;ved=2ahUKEwjLsIeRndeCAxUulGoFHU0RDrcQFnoECAgQAg\&amp;usg=AOvVaw08f8iaLIw7yHSVqajvFaVv</a></p>
<p>[19] Never Use ThreadLocal Variables In A J2EE Container Including OCCAS And OCSG (Doc ID 881757.1)<a href="https://support.oracle.com/knowledge/More%20Applications%20and%20Technologies/881757_1.html"> https://support.oracle.com/knowledge/More%20Applications%20and%20Technologies/881757_1.html</a></p>
<p>[20] src/java.base/share/classes/java/lang/ThreadLocal.java - platform/libcore.git - Git at Google<a href="https://android.googlesource.com/platform/libcore.git/+/refs/heads/upstream-openjdk/src/java.base/share/classes/java/lang/ThreadLocal.java"> https://android.googlesource.com/platform/libcore.git/+/refs/heads/upstream-openjdk/src/java.base/share/classes/java/lang/ThreadLocal.java</a></p>
<p>[21] Class ThreadLocal\<T><a href="http://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html"> http://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html</a></p>
<p>[22] Java 分布式项目多线程修改数据_mob64ca141834d3的技术博客_51CTO博客<a href="https://blog.51cto.com/u_16213716/12338832"> https://blog.51cto.com/u_16213716/12338832</a></p>
<p>[23] ThreadLocal :在 Java中隐匿的魔法之力-CSDN博客<a href="https://blog.csdn.net/zhengzhaoyang122/article/details/136548077"> https://blog.csdn.net/zhengzhaoyang122/article/details/136548077</a></p>
<p>[24] 全面理解ThreadLocal_threadlocal localmap = new threadlocal&lt; -CSDN博客<a href="https://blog.csdn.net/Weixiaohuai/article/details/116269475"> https://blog.csdn.net/Weixiaohuai/article/details/116269475</a></p>
<p>[25] 「学习笔记」深入理解threadlocal<a href="https://juejin.cn/post/6915746638736818189"> https://juejin.cn/post/6915746638736818189</a></p>
<p>[26] Class java.lang.ThreadLocal<a href="https://courses.cs.washington.edu/courses/cse341/98au/java/jdk1.2beta4/docs/api/java/lang/ThreadLocal.html"> https://courses.cs.washington.edu/courses/cse341/98au/java/jdk1.2beta4/docs/api/java/lang/ThreadLocal.html</a></p>
<p>[27] 浅析 ThreadLocal根据 Java 官方文档的描述，我们可知 ThreadLocal 类用于提供线程内部的局部变 - 掘金<a href="https://juejin.cn/post/6893490343661174797"> https://juejin.cn/post/6893490343661174797</a></p>
<p>[28] ThreadLocal用法及原理_threadlocal 如何让函数-CSDN博客<a href="https://blog.csdn.net/weixin_42638946/article/details/120199865"> https://blog.csdn.net/weixin_42638946/article/details/120199865</a></p>
<p>[29] 线程池(六):ThreadLocal相关知识详解_threadlocal 怎么跟当前线程绑定的-CSDN博客<a href="https://blog.csdn.net/Chenchen0905_/article/details/147539416"> https://blog.csdn.net/Chenchen0905_/article/details/147539416</a></p>
<p>[30] 深入学习Java多线程:ThreadLocal的全面解析与实践_圣逸的技术博客_51CTO博客<a href="https://blog.51cto.com/u_17035323/14112416"> https://blog.51cto.com/u_17035323/14112416</a></p>
<p>[31] SpringBoot 3.4 中 ThreadLocal 的使用技巧ThreadLocal 的概念 ThreadLoca - 掘金<a href="https://juejin.cn/post/7475285112760041523"> https://juejin.cn/post/7475285112760041523</a></p>
<p>[32] ThreadLocal - 原理与应用场景详解-阿里云开发者社区<a href="https://developer.aliyun.com/article/1661553"> https://developer.aliyun.com/article/1661553</a></p>
<p>[33] 反问面试官三个 ThreadLocal 的问题-51CTO.COM<a href="https://www.51cto.com/article/797697.html"> https://www.51cto.com/article/797697.html</a></p>
<p>[34] Java 中的 ThreadLocal:概念、应用及代码示例-腾讯云开发者社区-腾讯云<a href="https://cloud.tencent.com/developer/article/2489599"> https://cloud.tencent.com/developer/article/2489599</a></p>
<p>[35] ThreadLocal避坑指南:Java老司机总结的6个最佳实践_java threadlocal 最佳实践-CSDN博客<a href="https://blog.csdn.net/qq_44378083/article/details/147234358"> https://blog.csdn.net/qq_44378083/article/details/147234358</a></p>
<p>[36] Java 中使用 ThreadLocal 的最佳实践是什么?_threadlocal用作实例属性还是静态属性合适-CSDN博客<a href="https://blog.csdn.net/qq_63553317/article/details/145917804"> https://blog.csdn.net/qq_63553317/article/details/145917804</a></p>
<p>[37] 重学Java基础篇—ThreadLocal深度解析与最佳实践-腾讯云开发者社区-腾讯云<a href="https://cloud.tencent.com/developer/article/2506222"> https://cloud.tencent.com/developer/article/2506222</a></p>
<p>[38] ThreadLocal的理解和使用_王大师的技术博客_51CTO博客<a href="https://blog.51cto.com/wangwenfeng/12247204"> https://blog.51cto.com/wangwenfeng/12247204</a></p>
<p>[39] ThreadLocal:Java多线程编程的“利器”与“陷阱”-腾讯云开发者社区-腾讯云<a href="https://cloud.tencent.com/developer/article/2517742"> https://cloud.tencent.com/developer/article/2517742</a></p>
<p>[40] 深入探秘 Java 中的 ThreadLocal:原理、用法与最佳实践_从程序员到架构师<a href="http://m.toutiao.com/group/7536132384543097380/?upstream_biz=doubao"> http://m.toutiao.com/group/7536132384543097380/?upstream_biz=doubao</a></p>
<p>[41] 深入解析 Java 中的 ThreadLocal:原理、最佳实践与应用场景 本文全面剖析了 Java 中 ThreadL - 掘金<a href="https://juejin.cn/post/7456275611302330377"> https://juejin.cn/post/7456275611302330377</a></p>
<p>[42] 从源码角度分析导致 JVM 内存泄露的 ThreadLocal-CSDN博客<a href="https://blog.csdn.net/m0_60963435/article/details/149869313"> https://blog.csdn.net/m0_60963435/article/details/149869313</a></p>
<p>[43] ThreadLocal介绍和源码解析_cleansomeslots-CSDN博客<a href="https://blog.csdn.net/m0_37756917/article/details/123133728"> https://blog.csdn.net/m0_37756917/article/details/123133728</a></p>
<p>[44] Java OOM如何分析_jkfox的技术博客_51CTO博客<a href="https://blog.51cto.com/u_13479/12651126"> https://blog.51cto.com/u_13479/12651126</a></p>
<p>[45] ThreadLocal 核心源码分析 - 城北有个混子 - 博客园<a href="https://www.cnblogs.com/ruoli-0/p/18247881"> https://www.cnblogs.com/ruoli-0/p/18247881</a></p>
<p>[46] 深入解析 Java 中的 ThreadLocal:原理、最佳实践与应用场景 本文全面剖析了 Java 中 ThreadL - 掘金<a href="https://juejin.cn/post/7456275611302330377"> https://juejin.cn/post/7456275611302330377</a></p>
<p>[47] 【ThreadLocal全面解析】原理、使用与内存泄漏深度剖析，看这一文就够了! - 佛祖让我来巡山 - 博客园<a href="https://www.cnblogs.com/sun-10387834/p/19000053.html"> https://www.cnblogs.com/sun-10387834/p/19000053.html</a></p>
<p>[48] ThreadLocal的源码解析以及内存泄漏的原理分析介绍了Java中的ThreadLocal的作用、原理、源码以及应用 - 掘金<a href="https://juejin.cn/post/7021355637812494366"> https://juejin.cn/post/7021355637812494366</a></p>
<p>[49] 为什么ThreadLocalMap中的ThreadLocal是弱引用类型!-CSDN博客<a href="https://blog.csdn.net/2301_78191305/article/details/146394097"> https://blog.csdn.net/2301_78191305/article/details/146394097</a></p>
<p>[50] ThreadLocal源码分析-CSDN博客<a href="https://blog.csdn.net/u014753478/article/details/114281402"> https://blog.csdn.net/u014753478/article/details/114281402</a></p>
<p>[51] 实战指南:理解 ThreadLocal 原理并用于Java 多线程上下文管理 - 测试小萌新一枚 - 博客园<a href="https://www.cnblogs.com/-lhl/articles/18764184"> https://www.cnblogs.com/-lhl/articles/18764184</a></p>
<p>[52] 深入理解ThreadLocal及其弱引用-阿里云开发者社区<a href="https://developer.aliyun.com/article/1642299"> https://developer.aliyun.com/article/1642299</a></p>
<p>[53] ThreadLocal 内存泄露问题是怎么导致的?_51CTO博客_threadlocal 内存泄露原理<a href="https://blog.51cto.com/zhangxueliang/9964398"> https://blog.51cto.com/zhangxueliang/9964398</a></p>
<p>[54] 真实系统中 ThreadLocal 的实战分析与架构设计_threadlocal实战-CSDN博客<a href="https://blog.csdn.net/weixin_45525272/article/details/144012110"> https://blog.csdn.net/weixin_45525272/article/details/144012110</a></p>
<p>[55] 《多线程下ThreadLocal使用场景实例精选》_多线程使用threadlocal案例-CSDN博客<a href="https://blog.csdn.net/ke1ying/article/details/116796733"> https://blog.csdn.net/ke1ying/article/details/116796733</a></p>
<p>[56] 深入学习Java多线程:ThreadLocal的全面解析与实践_圣逸的技术博客_51CTO博客<a href="https://blog.51cto.com/u_17035323/14112416"> https://blog.51cto.com/u_17035323/14112416</a></p>
<p>[57] 理解 Java 的 ThreadLocal_wx661607c93692e的技术博客_51CTO博客<a href="https://blog.51cto.com/leett/13986411"> https://blog.51cto.com/leett/13986411</a></p>
<p>[58] 太坑了，ThreadLocal怎么老是泄露!本文将介绍一下ThreadLocald常用的`使用场景`，通过源码`解析原理 - 掘金<a href="https://juejin.cn/post/7447212089981321266"> https://juejin.cn/post/7447212089981321266</a></p>
<p>[59] ThreadLocal - 原理与应用场景详解-阿里云开发者社区<a href="https://developer.aliyun.com/article/1661553"> https://developer.aliyun.com/article/1661553</a></p>
<p>[60] threadlocal适合用在哪些实际生产场景中海量资源.pdf-原创力文档<a href="https://m.book118.com/html/2024/1014/5123011342011332.shtm"> https://m.book118.com/html/2024/1014/5123011342011332.shtm</a></p>
<p>[61] ThreadLocal总结_threadlocalholder.begin作用-CSDN博客<a href="https://blog.csdn.net/shuoyueqishilove/article/details/149837067"> https://blog.csdn.net/shuoyueqishilove/article/details/149837067</a></p>
<p>[62] 2025 年四个 ThreadLocal 应用场景ThreadLocal 是 Java 中一个非常有用的类，它用于提供线 - 掘金<a href="https://juejin.cn/post/7551955877316001826"> https://juejin.cn/post/7551955877316001826</a></p>
<p>[63] Java并发编程的隐秘武器:ThreadLocal深度解析-CSDN博客<a href="https://blog.csdn.net/2401_88677290/article/details/144307226"> https://blog.csdn.net/2401_88677290/article/details/144307226</a></p>
<p>[64] 深入解析 Java 中的 ThreadLocal:原理、最佳实践与应用场景 本文全面剖析了 Java 中 ThreadL - 掘金<a href="https://juejin.cn/post/7456275611302330377"> https://juejin.cn/post/7456275611302330377</a></p>
<p>[65] 面试 ThreadLocal，被问懵了?看完这篇文章你就稳了!_软件求生的技术博客_51CTO博客<a href="https://blog.51cto.com/u_16237826/13669223"> https://blog.51cto.com/u_16237826/13669223</a></p>
<p>[66] Java中ThreadLocal变量使用技巧-java教程-PHP中文网<a href="https://m.php.cn/faq/1534445.html"> https://m.php.cn/faq/1534445.html</a></p>
<p>[67] Java ThreadLocal的应用场景 - 摩柯技术社区<a href="https://moke.laixiai.com/post/17e85327d2924dfe99c27408904dd0ce"> https://moke.laixiai.com/post/17e85327d2924dfe99c27408904dd0ce</a></p>
<p>[68] ThreadLocal使用陷阱详解-CSDN博客<a href="https://blog.csdn.net/qq_35971258/article/details/146281882"> https://blog.csdn.net/qq_35971258/article/details/146281882</a></p>
<p>[69] 解锁ThreadLocal的问题集:如何规避多线程中的坑_threadlocal多线程的坑-CSDN博客<a href="https://blog.csdn.net/Mrxiao_bo/article/details/136208633"> https://blog.csdn.net/Mrxiao_bo/article/details/136208633</a></p>
<p>[70] ThreadLocal:Java多线程编程的“利器”与“陷阱”-腾讯云开发者社区-腾讯云<a href="https://cloud.tencent.com/developer/article/2517742"> https://cloud.tencent.com/developer/article/2517742</a></p>
<p>[71] ThreadLocal使用过程中要注意哪些事项 - 使用D - 博客园<a href="https://www.cnblogs.com/use-D/p/18224878"> https://www.cnblogs.com/use-D/p/18224878</a></p>
<p>[72] 深入解析 Java 中的 ThreadLocal:原理、最佳实践与应用场景 本文全面剖析了 Java 中 ThreadL - 掘金<a href="https://juejin.cn/post/7456275611302330377"> https://juejin.cn/post/7456275611302330377</a></p>
<p>[73] ThreadLocal如何解决内存泄漏_threadlocal内存泄露如何解决-CSDN博客<a href="https://blog.csdn.net/qq_47183158/article/details/143884242"> https://blog.csdn.net/qq_47183158/article/details/143884242</a></p>
<p>[74] ThreadLocal为什么会内存泄漏?如何解决?_threadlocal内存泄露的原理-CSDN博客<a href="https://blog.csdn.net/qq_41520636/article/details/143093300"> https://blog.csdn.net/qq_41520636/article/details/143093300</a></p>
<p>[75] 如何解决ThreadLocal内存泄漏问题?_ysp2338084的技术博客_51CTO博客<a href="https://blog.51cto.com/yangshaoping/14050740"> https://blog.51cto.com/yangshaoping/14050740</a></p>
<p>[76] 阿里 P7 级面试题:ThreadLocal 为什么会内存泄漏?如何解决?_软件求生的技术博客_51CTO博客<a href="https://blog.51cto.com/u_16237826/13700191"> https://blog.51cto.com/u_16237826/13700191</a></p>
<p>[77] ThreadLocal 内存泄漏原因和解决方法 - jock_javaEE - 博客园<a href="https://www.cnblogs.com/jock766/p/18750823"> https://www.cnblogs.com/jock766/p/18750823</a></p>
<p>[78] ThreadLocal 有哪些潜在的问题?如何避免内存泄漏? - 蒟蒻00 - 博客园<a href="https://www.cnblogs.com/cabbagehp/p/18801641"> https://www.cnblogs.com/cabbagehp/p/18801641</a></p>
<p>[79] ThreadLocal内存泄露的产生原因和处理方法_java_脚本之家<a href="https://www.jb51.net/program/332936ojq.htm"> https://www.jb51.net/program/332936ojq.htm</a></p>
<blockquote>
<p>（注：文档部分内容可能由 AI 生成）</p>
</blockquote>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      CMZT CC-BY-4.0
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
    <a href="https://github.com/cmzt-coder" target="_blank" rel="noopener" title="GitHub | CMZT" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.0.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.tabs", "navigation.top", "navigation.indexes", "navigation.expand", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../../../mkdocs/javascripts/katex.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/contrib/auto-render.min.js"></script>
      
        <script src="../../../mkdocs/javascripts/external-links.js"></script>
      
        <script src="../../../mkdocs/javascripts/fireworks.js"></script>
      
    
  </body>
</html>