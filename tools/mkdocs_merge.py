#!/usr/bin/env python3
"""
Merge split MkDocs config parts into a single mkdocs.yml.

Edit files under mkdocs_parts/ and run:
  python tools/mkdocs_merge.py

This script requires PyYAML:
  python -m pip install pyyaml
"""

import os
import sys
from pathlib import Path

# 尝试导入PyYAML库，用于处理YAML文件
try:
    import yaml
except ModuleNotFoundError:
    print("[mkdocs_merge] PyYAML not found. Install with: python -m pip install pyyaml", file=sys.stderr)
    sys.exit(1)

# 定义项目根目录、部件目录和输出文件路径
ROOT = Path(__file__).resolve().parents[1]  # 获取脚本所在目录的上两级目录（项目根目录）
PARTS_DIR = ROOT / "mkdocs_parts"           # 配置片段所在的目录
OUTPUT_FILE = ROOT / "mkdocs.yml"          # 合并后的输出文件路径

# 定义需要合并的配置文件列表，按指定顺序处理以保证最终布局的可读性
PART_FILES = [
    "info.yml",              # 基本项目信息
    "nav.yml",               # 导航配置
    "theme.yml",             # 主题设置
    "repo.yml",              # 仓库相关设置
    "copyright.yml",         # 版权信息
    "extra.yml",             # 额外配置
    "plugins.yml",           # 插件配置
    "markdown_extensions.yml", # Markdown扩展配置
    "assets.yml",            # 静态资源配置
]

def deep_update(base, new):
    """
    递归深度更新字典函数
    
    Args:
        base (dict): 基础字典，将被更新
        new (dict): 新字典，包含要更新的值
    """
    from collections.abc import Mapping
    # 遍历新字典中的每个键值对
    for k, v in new.items():
        # 如果值是字典且基础字典中对应键也是字典，则递归更新
        if isinstance(v, Mapping) and isinstance(base.get(k), Mapping):
            deep_update(base[k], v)
        else:
            # 否则直接赋值
            base[k] = v

def main():
    """
    主函数：合并所有配置片段到单个mkdocs.yml文件
    """
    # 检查配置片段目录是否存在
    if not PARTS_DIR.exists():
        print(f"[mkdocs_merge] Parts directory not found: {PARTS_DIR}", file=sys.stderr)
        sys.exit(2)

    # 初始化空的配置字典
    config = {}
    
    # 按顺序遍历所有配置片段文件
    for fname in PART_FILES:
        fp = PARTS_DIR / fname
        # 检查文件是否存在
        if not fp.exists():
            print(f"[mkdocs_merge] Skipping missing part: {fname}")
            continue
        
        # 打开并读取YAML配置文件
        with fp.open("r", encoding="utf-8") as f:
            # 使用safe_load加载YAML内容，如果为空则返回空字典
            part = yaml.safe_load(f) or {}
            # 将当前部分合并到主配置中
            deep_update(config, part)

    # 创建文件头注释，说明该文件是自动生成的
    header = (
        "# This file is generated by tools/mkdocs_merge.py\n"
        "# Do not edit directly — edit files in mkdocs_parts/ instead.\n"
    )

    # 将合并后的配置转换为YAML字符串格式
    # allow_unicode=True: 允许Unicode字符
    # sort_keys=False: 不对键进行排序以保持原有顺序
    # width=120: 设置行宽为120字符
    yaml_str = yaml.dump(
        config, allow_unicode=True, sort_keys=False, width=120
    )

    # 将生成的YAML写入输出文件
    with OUTPUT_FILE.open("w", encoding="utf-8") as f:
        f.write(header)
        f.write(yaml_str)

    # 输出成功信息
    print(f"[mkdocs_merge] Wrote {OUTPUT_FILE}")

# 当脚本被直接执行时运行main函数
if __name__ == "__main__":
    main()